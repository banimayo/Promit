<!DOCTYPE html>
<html lang="ko" data-theme="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Promit</title>
    <link rel="icon"
        href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='22' fill='%235e9c7e'/%3E%3Ccircle cx='30' cy='30' r='8' fill='white'/%3E%3Ccircle cx='50' cy='50' r='8' fill='white'/%3E%3Ccircle cx='70' cy='70' r='8' fill='white'/%3E%3C/svg%3E">
    <style>
        :root {
            --bg-color: #f0f2f5;
            --surface: #ffffff;
            --surface-hover: #f8f9fa;
            --text-main: #2c3e50;
            --text-sub: #7f8c8d;
            --border: #e4e6eb;
            --highlight: #3498db;
            --highlight-text: #ffffff;
            --danger: #ff3b30;
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            --popover-bg: rgba(255, 255, 255, 0.98);
            --popover-border: rgba(0, 0, 0, 0.1);
            --chip-text: #2c3e50;
            --arrow-color: rgba(0, 0, 0, 0.2);
            --arrow-hover: #3498db;
            --fav-item-height: 64px;
        }

        [data-theme="dark"] {
            --bg-color: #121212;
            --surface: #1e1e1e;
            --surface-hover: #2c2c2c;
            --text-main: #e4e6eb;
            --text-sub: #b0b3b8;
            --border: #3e4042;
            --highlight: #3498db;
            --highlight-text: #ffffff;
            --danger: #ff453a;
            --shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            --popover-bg: rgba(35, 35, 35, 0.98);
            --popover-border: rgba(255, 255, 255, 0.1);
            --arrow-color: rgba(255, 255, 255, 0.2);
            --arrow-hover: #3498db;
            --chip-text: #f5f7fb;
        }

        * {
            box-sizing: border-box;
            outline: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            min-height: 100vh;
            overflow-y: auto;
            overflow-x: hidden;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .app-shell {
            width: 100%;
            max-width: 680px;
            min-height: 100vh;
            height: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            overflow: visible;
        }

        .app-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 4px 0;
            margin-bottom: 4px;
        }

        .branding {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .app-title {
            font-size: 22px;
            font-weight: 800;
            letter-spacing: -0.5px;
            color: var(--text-main);
            margin: 0;
        }

        .app-version {
            font-size: 10px;
            font-weight: 700;
            background: var(--highlight);
            color: var(--highlight-text);
            padding: 3px 6px;
            border-radius: 6px;
        }

        .header-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .settings-dropdown {
            position: relative;
        }

        .language-dropdown {
            position: relative;
        }

        .settings-menu {
            position: absolute;
            top: calc(100% + 8px);
            right: 0;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 14px;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.25);
            display: none;
            flex-direction: column;
            min-width: 200px;
            z-index: 200;
            overflow: hidden;
            padding: 6px 0;
        }

        .settings-menu.open {
            display: flex;
        }

        .language-menu {
            position: absolute;
            top: calc(100% + 8px);
            right: 0;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 14px;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.25);
            display: none;
            flex-direction: column;
            min-width: 140px;
            z-index: 200;
            overflow: hidden;
        }

        .language-menu.open {
            display: flex;
        }

        .language-menu button {
            background: transparent;
            border: none;
            padding: 10px 14px;
            font-size: 13px;
            color: var(--text-main);
            text-align: left;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: background 0.2s ease, color 0.2s ease;
        }

        .language-menu button.active {
            color: var(--highlight);
            font-weight: 600;
        }

        .language-menu button:hover {
            background: var(--surface-hover);
            color: var(--highlight);
        }

        .settings-menu button,
        .settings-menu .settings-row {
            background: transparent;
            border: none;
            padding: 12px 18px;
            font-size: 14px;
            color: var(--text-main);
            text-align: left;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: background 0.2s ease, color 0.2s ease;
        }

        .settings-menu button:hover,
        .settings-menu .settings-row:hover {
            background: var(--surface-hover);
            color: var(--highlight);
        }

        .settings-menu .settings-row {
            cursor: pointer;
            justify-content: space-between;
        }

        .settings-menu .settings-divider {
            height: 1px;
            background: var(--border);
            margin: 6px 0;
        }

        .theme-toggle {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 10px;
            width: 100%;
        }

        .theme-toggle-switch {
            position: relative;
            width: 46px;
            height: 24px;
            border-radius: 999px;
            background: var(--border);
            transition: background 0.2s ease;
        }

        .theme-toggle-switch::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--surface);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s ease;
        }

        [data-theme="dark"] .theme-toggle-switch {
            background: var(--highlight);
        }

        [data-theme="dark"] .theme-toggle-switch::after {
            transform: translateX(22px);
        }

        .icon-btn {
            background: var(--surface);
            border: none;
            color: var(--text-main);
            width: 36px;
            height: 36px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px;
            transition: 0.2s;
        }

        .icon-btn:hover {
            background: var(--surface-hover);
        }

        .icon-btn:active {
            transform: scale(0.95);
        }

        .capsule-area {
            display: flex;
            flex-wrap: wrap;
            gap: 0;
            column-gap: 0;
            row-gap: 10px;
            align-items: center;
            justify-content: flex-start;
            margin-bottom: 8px;
        }

        .cap {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 8px 14px;
            background: var(--surface);
            border: 1px solid transparent;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 700;
            font-family: inherit;
            color: var(--text-main);
            cursor: pointer;
            user-select: none;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            min-height: 34px;
            padding-left: 18px;
            padding-right: 18px;
        }

        .cap:active {
            transform: scale(0.96);
        }

        .cap.active {
            border-color: transparent;
            color: var(--text-main);
            font-weight: 700;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .cap.dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }

        .cap:hover:not(.dragging) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .cap.cap-editing {
            transform: none !important;
            box-shadow: inset 0 0 0 2px var(--highlight);
            cursor: pointer;
        }

        .cap-add {
            width: 34px;
            height: 34px;
            padding: 0;
            font-size: 18px;
            border-style: dashed;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            color: var(--text-main);
            margin-left: 12px;
        }

        [data-theme="dark"] .cap-add {
            color: #fff;
        }

        .cap-edit-dialog {
            position: absolute;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 14px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.25);
            width: 220px;
            z-index: 400;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .cap-edit-title {
            font-size: 13px;
            font-weight: 700;
            color: var(--text-main);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 6px;
        }

        .cap-edit-title span {
            font-size: 11px;
            font-weight: 500;
            color: var(--text-sub);
            white-space: nowrap;
        }

        .cap-edit-input {
            width: 100%;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 6px 8px;
            font-size: 13px;
            background: var(--bg-color);
            color: var(--text-main);
        }

        .cap-edit-actions {
            display: flex;
            justify-content: space-between;
            gap: 12px;
        }

        .cap-edit-actions button {
            border: none;
            border-radius: 8px;
            padding: 6px 12px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
        }

        .cap-edit-actions .btn-confirm {
            background: var(--highlight);
            color: var(--highlight-text);
            transition: background 0.2s ease, color 0.2s ease;
        }

        .cap-edit-actions .btn-confirm.is-danger {
            background: var(--danger);
            color: #fff;
        }

        .cap-edit-actions .btn-cancel {
            background: var(--surface-hover);
            color: var(--text-main);
        }

        .editor-area {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            flex-shrink: 0;
        }

        .nav-arrow {
            background: none;
            border: none;
            padding: 0 14px;
            color: var(--arrow-color);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 26px;
            line-height: 1;
            cursor: pointer;
            user-select: none;
            transition: color 0.15s ease;
        }

        .nav-arrow:hover {
            color: var(--arrow-hover);
        }

        .nav-arrow:active {
            color: var(--text-main);
        }

        .nav-arrow.disabled {
            opacity: 0.15;
            pointer-events: none;
        }

        .editor-card {
            width: 100%;
            background: var(--surface);
            border-radius: 20px;
            padding: 24px;
            min-height: 320px;
            height: auto;
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            position: relative;
            border: none;
            transition: background 0.3s ease, border 0.3s ease;
        }

        .editor-header {
            position: absolute;
            top: 18px;
            left: 24px;
            right: 24px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 12px;
            z-index: 5;
        }

        /* 1. Ïª®ÌÖåÏù¥ÎÑà Î∞è Ïπ© Í∏∞Î≥∏ Ïä§ÌÉÄÏùº */
        .chip-container {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            align-content: flex-start;
            gap: 0;
            row-gap: 10px;
            padding: 0px;
            flex-grow: 1;
            margin-bottom: 20px;
            margin-top: 36px;
        }

        .chip-container.is-empty-drop {
            border: 1px dashed var(--border);
            border-radius: 18px;
            min-height: 140px;
            justify-content: center;
        }

        .chip-container.is-empty-drop.drag-over {
            border-color: var(--highlight);
            background: rgba(52, 152, 219, 0.08);
        }

        .chip {
            display: inline-flex;
            align-items: center;
            height: 38px;
            padding: 0 14px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 500;
            font-family: inherit;
            color: var(--text-main);
            cursor: pointer;
            user-select: none;
            transition: transform 0.2s ease, box-shadow 0.2s ease, color 0.2s ease, background 0.2s ease;
            border: 1px solid transparent;
            position: relative;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin: 0;
            z-index: 2;
            white-space: normal;
            line-height: 1.4;
            word-break: break-word;
            overflow: hidden;
        }

        .chip.is-empty {
            box-shadow: none;
        }

        .chip.linked-left {
            border-top-right-radius: 0px;
            border-bottom-right-radius: 0px;
            margin-right: 0;
            padding-right: 10px;
            z-index: 1;
            border-right: none;
        }

        .chip.linked-right {
            border-top-left-radius: 0px;
            border-bottom-left-radius: 0px;
            margin-left: 0;
            padding-left: 10px;
            border-left: none;
        }

        .chip.shift-left {
            transform: translateX(-10px);
        }

        .chip.shift-right {
            transform: translateX(10px);
        }

        /* 2. Ïπ© ÏÇ¨Ïù¥ Í∞ÑÍ≤©(Î∏åÎ¶øÏßÄ) ÏÑ§Ï†ï */
        .chip-bridge {
            width: 12px;
            height: 38px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            z-index: 10;
            user-select: none;
            transition: transform 0.18s ease;
        }

        .chip-bridge.active {
            width: 12px;
            margin: 0 -6px;
            opacity: 0;
        }

        /* [Ï§ëÏöî] ::beforeÎäî Ìà¨Î™Ö ÌûàÌä∏Î∞ïÏä§ Ïó≠Ìï†Îßå ÏàòÌñâ (ÏÉâÏÉÅ ÏóÜÏùå) */
        /* pointer-events: noneÏúºÎ°ú ÎìúÎ°≠ Ïù¥Î≤§Ìä∏Í∞Ä Ïã§Ï†ú ÏöîÏÜåÏóê Ï†ÑÎã¨ÎêòÎèÑÎ°ù Ìï® */
        .chip-bridge::before,
        .chip-drop-zone::before,
        .chip-tail-drop::before,
        .cap-drop-zone::before,
        .fav-drop-zone::before {
            content: '';
            position: absolute;
            top: -15px;
            bottom: -15px;
            left: -12px;
            right: -12px;
            z-index: 20;
            background: transparent !important;
            pointer-events: none;
        }

        /* ÎìúÎûòÍ∑∏ Ïãú ÌûàÌä∏Î∞ïÏä§ Ïä§ÌÉÄÏùº Ï¥àÍ∏∞Ìôî (Î∞∞Í≤ΩÏÉâ Ï†àÎåÄ Í∏àÏßÄ) */
        .chip-bridge.drag-over-gap::before,
        .chip-drop-zone.drag-over-gap::before,
        .chip-tail-drop.drag-over-gap::before,
        .cap-drop-zone.drag-over-gap::before,
        .fav-drop-zone.drag-over-gap::before {
            background: transparent !important;
            box-shadow: none !important;
            opacity: 0 !important;
            border: none !important;
        }

        /* 3. ÏãúÍ∞ÅÏ†Å ÌïòÏù¥ÎùºÏù¥Ìä∏ (ÏÑ∏Î°ú Ï∫°Ïäê) */
        /* [ÌïµÏã¨] active ÏÉÅÌÉúÎÇò tail ÌÅ¥ÎûòÏä§ÏóêÏÑúÎèÑ Í∞ïÏ†úÎ°ú Î≥¥Ïù¥ÎèÑÎ°ù ÏÖÄÎ†âÌÑ∞ Î™®Îëê Ìè¨Ìï® */
        .chip-bridge.drag-over-gap::after,
        .chip-drop-zone.drag-over-gap::after,
        .chip-tail-drop.drag-over-gap::after,
        .cap-drop-zone.drag-over-gap::after,
        .fav-drop-zone.drag-over-gap::after,
        .fav-drop-zone.gap-preview-active::after,
        .chip-bridge.active.drag-over-gap::after {
            content: '' !important;
            display: block !important;
            /* display:none Í∞ïÏ†ú Ìï¥Ï†ú */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            /* Ï∫°Ïäê ÎëêÍªò */
            height: 28px;
            /* Ï∫°Ïäê ÎÜíÏù¥ */
            background-color: var(--highlight) !important;
            border-radius: 4px;
            z-index: 100;
            box-shadow: 0 0 8px rgba(52, 152, 219, 0.6);
            opacity: 1 !important;
            pointer-events: none;
            animation: none;
        }

        /* 4. ÎßÅÌÅ¨ Ï†ê(Dot) Ïä§ÌÉÄÏùº */
        .chip-bridge::after {
            content: '';
            position: absolute;
            width: 4px;
            height: 4px;
            background: var(--border);
            border-radius: 50%;
            transition: 0.2s;
            opacity: 0.5;
            z-index: 5;
            pointer-events: none;
        }

        /* ÎßÅÌÅ¨ ÏÉÅÌÉúÏùº Îïå Ï†ê Ïà®ÍπÄ */
        .chip-bridge.active::after {
            display: none;
        }

        body.is-dragging .chip-bridge::after {
            opacity: 0 !important;
        }

        /* ÎìúÎûòÍ∑∏ Ï§ëÏóêÎäî ÎßÅÌÅ¨Îêú Î∏åÎ¶øÏßÄÎèÑ ÌûàÌä∏Î∞ïÏä§ ÏòÅÏó≠ ÌôïÎ≥¥ */
        body.is-dragging .chip-bridge.active {
            width: 24px;
            margin: 0 -12px;
        }

        /* drag-over-gapÏùº ÎïåÎäî ÌïòÏù¥ÎùºÏù¥Ìä∏ Ï∫°Ïäê ÌëúÏãú (ÏúÑ Í∑úÏπô Ïò§Î≤ÑÎùºÏù¥Îìú) */
        body.is-dragging .chip-bridge.drag-over-gap::after {
            opacity: 1 !important;
        }

        .chip-link-toggle {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 6px;
            height: 30px;
            border-radius: 4px;
            background: var(--danger);
            transform: translate(-50%, -50%) scale(0.8);
            opacity: 0;
            box-shadow: 0 0 10px rgba(255, 59, 48, 0.6);
            transition: opacity 0.15s ease, transform 0.15s ease;
            pointer-events: auto;
            z-index: 50;
        }

        .chip-link-toggle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 18px;
            border-radius: 2px;
            background: rgba(255, 255, 255, 0.5);
            transform: translate(-50%, -50%);
        }

        body.is-dragging .chip-link-toggle {
            pointer-events: none;
            opacity: 0 !important;
        }

        body:not(.is-dragging):not(.is-edit-mode) .chip-bridge.active:hover .chip-link-toggle,
        .chip-link-toggle:hover {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            cursor: pointer;
        }

        .chip-bridge.drag-over-gap .chip-link-toggle {
            display: none;
        }

        /* 5. ÎìúÎ°≠Ï°¥(Head/Tail) ÏòÅÏó≠ ÏÑ§Ï†ï */
        .chip-drop-zone {
            display: inline-flex;
            height: 38px;
            position: relative;
            z-index: 5;
            align-items: center;
            justify-content: center;
            transition: transform 0.18s ease;
        }

        .chip-drop-zone.head {
            width: 18px;
            flex: 0 0 18px;
            margin-left: -18px;
            margin-right: 6px;
        }

        .chip-drop-zone.tail {
            flex-grow: 1;
            min-width: 40px;
            width: auto;
        }

        .cap-drop-zone {
            width: 8px;
            height: 34px;
            display: inline-flex;
            position: relative;
            align-items: center;
            justify-content: center;
            transition: transform 0.18s ease;
            flex: 0 0 8px;
        }

        .cap-drop-zone.head {
            margin-left: -8px;
        }

        .cap-drop-zone.tail {
            margin-right: -8px;
        }

        .cap.shift-left {
            transform: translateX(-8px) !important;
        }

        .cap.shift-right {
            transform: translateX(8px) !important;
        }

        .chip-drop-zone.gap-preview-edge-left {
            transform: translateX(10px);
        }

        .chip-drop-zone.gap-preview-edge-right {
            transform: translateX(-10px);
        }

        .chip-drop-zone.head.drag-over-gap::after {
            left: 50%;
            right: auto;
            transform: translate(-50%, -50%);
        }

        .chip-drop-zone.tail.drag-over-gap::after {
            left: 4px;
            right: auto;
            transform: translate(-30%, -50%);
        }

        /* chip-tail-drop ÌÅ¥ÎûòÏä§ Ìò∏ÌôòÏÑ± Ïú†ÏßÄ */
        .chip-tail-drop {
            display: inline-flex;
            position: relative;
            z-index: 5;
            width: 12px;
            height: 38px;
            flex-grow: 0;
            flex-shrink: 0;
        }

        /* 6. Ïπ© ÎìúÎûòÍ∑∏ Î∞è Ïï†ÎãàÎ©îÏù¥ÏÖò */
        .chip.dragging {
            opacity: 0.4;
            transform: scale(0.95);
            filter: grayscale(100%);
        }

        @keyframes chipPopIn {
            0% {
                transform: scale(0.85);
                opacity: 0;
            }

            70% {
                transform: scale(1.05);
                opacity: 1;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* ÏÇ≠Ï†ú Î™®Îìú: ÏïΩÌïú Îñ®Î¶º + Ìò∏Î≤Ñ Ïãú Îπ®Í∞Ñ Í∏ÄÎ°úÏö∞ */
        .chip.pop-in {
            animation: chipPopIn 0.3s ease;
        }

        .chip-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-right: 2px;
            margin-left: -4px;
            cursor: pointer;
            font-size: 16px;
            transition: transform 0.2s;
            user-select: none;
        }

        .chip-icon:hover {
            transform: scale(1.2);
        }

        .chip-icon:active {
            transform: scale(0.9);
        }

        .popover {
            position: absolute;
            background: var(--popover-bg);
            backdrop-filter: blur(12px);
            border-radius: 14px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            z-index: 100;
            display: none;
            flex-direction: column;
            border: 1px solid var(--popover-border);
            animation: popIn 0.15s cubic-bezier(0.2, 0.8, 0.2, 1);
            min-width: 220px;
            width: fit-content;
            max-width: 320px;
        }

        @keyframes popIn {
            from {
                opacity: 0;
                transform: scale(0.95) translateY(-10px);
            }

            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .popover.active {
            display: flex;
        }

        .pop-list {
            max-height: 220px;
            overflow-y: auto;
            padding: 6px 0;
        }

        .pop-section-label {
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.6px;
            color: var(--text-sub);
            padding: 6px 16px 2px 16px;
        }

        .pop-item {
            padding: 10px 16px;
            font-size: 13px;
            color: var(--text-main);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: 36px;
            gap: 8px;
        }

        .pop-item:hover {
            background: var(--surface-hover);
        }

        .pop-item.selected {
            background: rgba(52, 152, 219, 0.15);
            color: var(--highlight);
            font-weight: 600;
        }

        .pop-item.is-search-match {
            outline: 1px solid var(--highlight);
            background: rgba(52, 152, 219, 0.1);
        }

        .pop-option-label {
            flex: 1;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            color: var(--text-main);
        }

        .pop-edit-btn {
            border: none;
            background: transparent;
            cursor: pointer;
            padding: 2px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: background 0.15s ease;
            color: var(--text-sub);
        }

        .pop-edit-btn:hover {
            background: rgba(255, 255, 255, 0.08);
            color: var(--highlight);
        }

        .pop-edit-btn svg {
            width: 16px;
            height: 16px;
            stroke: currentColor;
        }

        [data-theme="light"] .pop-edit-btn:hover {
            background: rgba(0, 0, 0, 0.05);
        }

        [data-theme="dark"] .pop-option-label {
            color: var(--text-main);
        }

        [data-theme="dark"] .pop-edit-btn {
            color: #f0f0f0;
        }

        .pop-item.random-opt {
            color: #e67e22;
            font-style: italic;
        }

        .inline-edit-input {
            width: 100%;
            border: 1px solid var(--highlight);
            border-radius: 4px;
            padding: 4px;
            font-size: 13px;
            background: var(--bg-color);
            color: var(--text-main);
        }

        .pop-add-row {
            padding: 10px 12px;
            border-top: 1px solid var(--border);
        }

        .pop-add-input {
            width: 100%;
            border: 1px solid var(--border);
            background: var(--bg-color);
            color: var(--text-main);
            border-radius: 8px;
            padding: 8px 10px;
            font-size: 13px;
        }

        .footer {
            margin-top: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            border-top: 1px solid var(--border);
            padding: 20px 10px 0 10px;
        }

        .nav-row {
            width: 100%;
            display: grid;
            grid-template-columns: auto 1fr auto;
            align-items: center;
            gap: 16px;
        }

        .chip-trash {
            height: 46px;
            min-width: 64px;
            border: 1px dashed var(--border);
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-sub);
            font-size: 24px;
            padding: 0 14px;
            transition: border 0.2s ease, color 0.2s ease, background 0.2s ease;
            cursor: default;
        }

        .chip-trash .trash-icon {
            font-size: 24px;
        }

        .chip-trash.drag-over {
            border-color: var(--danger);
            color: var(--danger);
            background: rgba(255, 59, 48, 0.08);
        }

        .nav-controls {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            flex-wrap: nowrap;
            justify-content: center;
            justify-self: center;
        }

        .btn {
            padding: 0 16px;
            height: 46px;
            border: none;
            border-radius: 12px;
            font-weight: 700;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: 0.2s;
        }

        .btn:active {
            transform: scale(0.97);
        }

        @keyframes rollBounce {
            0% {
                transform: translateY(0) rotate(0deg) scale(1);
            }

            5% {
                transform: translateY(-8px) rotate(30deg) scale(1.05);
            }

            12% {
                transform: translateY(-20px) rotate(100deg) scale(1.1);
            }

            22% {
                transform: translateY(-25px) rotate(200deg) scale(1.12);
            }

            35% {
                transform: translateY(0) rotate(340deg) scale(0.95);
            }

            45% {
                transform: translateY(-14px) rotate(440deg) scale(1.06);
            }

            55% {
                transform: translateY(0) rotate(530deg) scale(0.97);
            }

            65% {
                transform: translateY(-6px) rotate(610deg) scale(1.03);
            }

            78% {
                transform: translateY(0) rotate(680deg) scale(0.99);
            }

            88% {
                transform: translateY(-2px) rotate(710deg) scale(1.01);
            }

            100% {
                transform: translateY(0) rotate(720deg) scale(1);
            }
        }

        .btn-gen {
            flex: 0 1 240px;
            max-width: 260px;
            background: linear-gradient(135deg, #7fb39d, #5e9c7e);
            color: white;
            font-size: 28px;
            box-shadow: 0 4px 15px rgba(94, 156, 126, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-weight: 800;
            justify-content: center;
            overflow: visible;
            padding: 0 100px;
        }

        .btn-gen .dice-icon {
            font-size: 32px;
            display: inline-block;
            transition: transform 0.15s ease;
        }

        .btn-gen.animating .dice-icon {
            animation: rollBounce 0.75s linear forwards;
        }

        .btn-gen:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(94, 156, 126, 0.4);
            filter: brightness(1.05);
        }

        .btn-gen:active {
            transform: translateY(0);
        }

        /* ÏÇ≠Ï†ú Î™®ÎìúÏùº Îïå Generate Î≤ÑÌäº ‚Üí Delete Mode Î≤ÑÌäºÏúºÎ°ú ÏôÑÏ†Ñ ÍµêÏ≤¥ */
        body.is-edit-mode .btn-gen {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
        }

        body.is-edit-mode .btn-gen:hover {
            box-shadow: 0 6px 20px rgba(231, 76, 60, 0.5);
        }

        body.is-edit-mode .btn-gen .dice-icon,
        body.is-edit-mode .btn-gen .btn-text {
            display: none;
        }

        body.is-edit-mode .btn-gen::after {
            content: 'üóëÔ∏è';
            font-size: 14px;
            letter-spacing: 1px;
        }

        .btn-copy {
            flex: 0 0 52px;
            background: transparent;
            color: var(--text-main);
            font-size: 24px;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.2s ease;
        }

        .btn-copy:hover {
            transform: scale(1.05);
            background: transparent;
        }

        .copy-controls {
            display: inline-flex;
            align-items: center;
            gap: 10px;
        }

        .btn-auto-copy {
            border: none;
            background: transparent;
            color: var(--text-sub);
            font-size: 22px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 2px;
            cursor: pointer;
            transition: color 0.2s ease;
        }

        .btn-auto-copy .auto-badge {
            font-size: 9px;
            font-weight: 700;
            letter-spacing: 0.6px;
            text-transform: uppercase;
        }

        .btn-auto-copy svg {
            width: 18px;
            height: 18px;
        }

        .btn-auto-copy.is-active {
            color: var(--highlight);
        }

        .btn-fav {
            background: transparent;
            color: var(--text-sub);
            font-size: 28px;
            border: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: color 0.2s ease, transform 0.2s ease;
            padding: 0;
        }

        .btn-fav.is-active {
            color: #ffd500;
        }

        .btn-fav-top {
            width: 32px;
            height: 32px;
            pointer-events: auto;
        }

        .btn-fav:hover {
            transform: scale(1.08);
            background: transparent;
        }

        .empty-state {
            width: 100%;
            text-align: center;
            color: var(--text-sub);
            margin-top: 60px;
            pointer-events: none;
            font-size: 14px;
            opacity: 0.6;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--text-sub);
            border-radius: 4px;
            opacity: 0.5;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        .btn-fav:hover {
            filter: drop-shadow(0 0 10px rgba(255, 213, 0, 0.35));
        }

        .dock-section {
            background: var(--surface);
            border: none;
            border-radius: 20px;
            padding: 20px;
            box-shadow: var(--shadow);
            display: flex;
            flex: none;
            min-height: calc(var(--fav-item-height) * 5 + 60px);
            max-height: calc(var(--fav-item-height) * 10 + 60px);
            margin-bottom: 10px;
            overflow: hidden;
            flex-direction: column;
            gap: 12px;
            animation: popIn 0.3s ease;
            margin-top: 10px;
        }

        .dock-tabs {
            display: flex;
            gap: 8px;
            border-bottom: 1px solid var(--border);
            padding-bottom: 6px;
            align-items: center;
        }

        .dock-tab {
            background: transparent;
            border: none;
            color: var(--text-sub);
            font-weight: 700;
            font-size: 13px;
            padding: 6px 10px;
            border-radius: 10px;
            cursor: pointer;
            transition: color 0.2s ease, background 0.2s ease;
        }

        .dock-tab.active {
            color: var(--text-main);
            background: var(--surface-hover);
        }

        .dock-actions {
            margin-left: auto;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .dock-clear-history {
            display: none;
            background: transparent;
            border: none;
            color: var(--text-sub);
            font-size: 18px;
            cursor: pointer;
            padding: 4px;
            border-radius: 8px;
            transition: color 0.2s ease, background 0.2s ease;
        }

        .dock-clear-history:hover {
            color: var(--danger);
            background: var(--surface-hover);
        }

        .dock-clear-history:disabled {
            opacity: 0.35;
            cursor: not-allowed;
        }

        .dock-mode-indicator {
            margin-left: 0;
            font-size: 11px;
            color: var(--danger);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .fav-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

        .fav-title {
            font-size: 16px;
            font-weight: 800;
            color: var(--text-main);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .dock-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex: 1 1 auto;
            min-height: calc(var(--fav-item-height) * 5);
            max-height: calc(var(--fav-item-height) * 10);
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 8px;
        }

        /* Ïä§ÌÅ¨Î°§Î∞î Ïä§ÌÉÄÏùº */
        .dock-list::-webkit-scrollbar {
            width: 6px;
        }

        .dock-list::-webkit-scrollbar-track {
            background: transparent;
        }

        .dock-list::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
        }

        .dock-list::-webkit-scrollbar-thumb:hover {
            background: var(--text-sub);
        }

        .fav-item,
        .history-item {
            display: flex;
            align-items: center;
            background: var(--bg-color);
            border: 1px solid transparent;
            border-radius: 14px;
            padding: 12px 16px;
            gap: 12px;
            transition: all 0.2s ease;
            position: relative;
        }

        .fav-item.deleting,
        .history-item.deleting {
            animation: dockItemDelete 0.18s cubic-bezier(0.4, 0, 0.2, 1) forwards;
            pointer-events: none;
        }

        .fav-item.highlight,
        .history-item.highlight {
            animation: highlightPulse 1s ease;
            border: 1px solid var(--highlight);
        }

        .fav-item.history-active,
        .history-item.history-active {
            border: 1px solid var(--highlight);
            background: rgba(52, 152, 219, 0.08);
        }

        @keyframes highlightPulse {
            0% {
                background-color: rgba(52, 152, 219, 0.1);
                transform: scale(1.02);
            }

            50% {
                background-color: rgba(52, 152, 219, 0.3);
                transform: scale(1.05);
            }

            100% {
                background-color: var(--bg-color);
                transform: scale(1);
            }
        }

        .fav-item:hover,
        .history-item:hover {
            border: 1px solid var(--highlight);
            transform: none !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .fav-content {
            flex: 1;
            cursor: pointer;
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            row-gap: 4px;
        }

        .history-item .fav-content {
            flex-wrap: nowrap;
            gap: 0;
        }

        .history-text {
            font-size: 13px;
            color: var(--text-main);
            line-height: 1.4;
            white-space: normal;
        }

        .fav-chip {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
            color: var(--text-main);
            font-weight: 500;
            font-family: inherit;
            display: inline-flex;
            align-items: center;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
            border: 0px solid transparent;
            position: relative;
            overflow: hidden;
        }

        [data-theme="dark"] .chip,
        [data-theme="dark"] .fav-chip,
        [data-theme="dark"] .cap {
            font-weight: 400;
        }

        .fav-chip.linked-left {
            border-top-right-radius: 0px;
            border-bottom-right-radius: 0px;
            margin-right: -2px;
            padding-right: 6px;
            z-index: 1;
            border-right: none;
        }

        .fav-chip.linked-right {
            border-top-left-radius: 0px;
            border-bottom-left-radius: 0px;
            margin-left: -2px;
            padding-left: 6px;
            border-left: none;
        }

        .fav-name-chip {
            padding: 8px 18px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
            background: rgba(94, 156, 126, 0.2);
            color: var(--text-main);
            display: inline-flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            user-select: none;
            transition: transform 0.18s ease, box-shadow 0.18s ease;
            border: 1px solid transparent;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.08);
            position: relative;
            z-index: 2;
        }

        [data-theme="dark"] .fav-name-chip {
            background: rgba(255, 255, 255, 0.08);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.45);
        }

        .fav-name-chip.dragging {
            opacity: 0.5;
            transform: scale(0.96);
        }

        .fav-name-chip.shift-left {
            transform: translateX(-8px);
        }

        .fav-name-chip.shift-right {
            transform: translateX(8px);
        }

        .fav-chip-board {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            align-content: flex-start;
            gap: 0;
            row-gap: 10px;
            padding: 8px 4px;
        }

        .fav-drop-zone {
            width: 8px;
            height: 36px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: transform 0.18s ease;
            flex: 0 0 8px;
        }

        .fav-drop-zone.head {
            margin-left: -8px;
        }

        .fav-drop-zone.tail {
            margin-right: -8px;
        }

        .active-fav-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 4px;
            min-width: 0;
        }

        .active-fav-label {
            flex: 1;
            font-size: 14px;
            font-weight: 700;
            color: var(--text-sub);
            min-height: 24px;
            visibility: hidden;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            pointer-events: none;
        }

        .active-fav-label.is-visible {
            visibility: visible;
            pointer-events: auto;
        }

        .active-fav-label.is-visible:not(.is-editing) {
            cursor: text;
        }

        .active-fav-label.is-editing {
            visibility: visible;
        }

        .active-fav-edit-btn {
            display: none;
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 50%;
            background: transparent;
            color: var(--text-sub);
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background 0.2s ease, color 0.2s ease;
            padding: 0;
        }

        .active-fav-edit-btn svg {
            width: 16px;
            height: 16px;
            pointer-events: none;
        }

        .active-fav-edit-btn:hover {
            color: var(--highlight);
            background: var(--surface-hover);
        }

        .active-fav-label.is-visible + .active-fav-edit-btn {
            display: inline-flex;
        }

        .active-fav-label.is-editing + .active-fav-edit-btn {
            display: none;
        }

        .active-fav-input {
            width: 100%;
            border: 1px solid var(--highlight);
            border-radius: 6px;
            padding: 2px 8px;
            font-size: 13px;
            font-weight: 600;
            background: var(--surface);
            color: var(--text-main);
        }

        .dock-empty {
            text-align: center;
            color: var(--text-sub);
            padding: 30px 10px;
            font-size: 13px;
        }

        .history-summary {
            font-size: 12px;
            color: var(--text-sub);
            width: 100%;
            margin-top: 4px;
            line-height: 1.4;
        }

        .dock-section.dock-delete-mode .fav-item {
            cursor: pointer;
            opacity: 0.9;
            transition: opacity 0.15s ease, background 0.15s ease, border 0.15s ease;
        }

        .dock-section.dock-delete-mode .fav-item:hover {
            background: #7f1d1d;
            border: 1px solid var(--danger);
            color: #fff;
            opacity: 1;
        }

        .dock-section.dock-delete-mode .fav-item:hover .fav-chip {
            background-color: rgba(255, 255, 255, 0.15) !important;
            color: #fff !important;
        }

        .dock-section.dock-delete-mode .fav-item:hover .history-summary {
            color: #ffe6e6;
        }

        .dock-section.dock-delete-mode .fav-item:hover .fav-btn {
            color: #fff;
        }

        .dock-section.dock-delete-mode .fav-item.history-active {
            border: 1px solid transparent;
            background: var(--bg-color);
        }

        @keyframes dockItemDelete {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }

            100% {
                transform: translateY(-12px) scale(0.6);
                opacity: 0;
            }
        }

        @media (min-width: 641px) {
            .editor-area {
                justify-content: center;
            }

            .nav-controls {
                justify-content: center;
            }

            .btn-gen {
                margin: 0 auto;
            }
        }

        @media (max-width: 640px) {
            .app-shell {
                padding: 12px;
            }

            .chip-container {
                padding: 0 2px;
            }

            .editor-card {
                padding: 16px;
            }

            .nav-row {
                column-gap: 10px;
            }

            .nav-controls {
                justify-content: center;
                gap: 6px;
                min-width: 0;
                margin: 0;
                justify-self: stretch;
                width: 100%;
            }

            .editor-area {
                justify-content: flex-start;
            }

            .btn-gen {
                max-width: none;
                flex: 1;
                width: 100%;
                padding: 0 32px;
            }

        }

        @media (max-width: 640px) {
            .nav-controls .btn-gen {
                flex: 1 1 auto;
            }
        }

        .fav-actions {
            display: flex;
            align-items: flex-start;
            gap: 2px;
            padding-top: 2px;
        }

        .fav-btn {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 16px;
            color: var(--text-sub);
            transition: 0.2s;
            background: transparent;
            border: none;
        }

        .fav-btn:hover {
            transform: scale(1.2);
            color: var(--text-main);
        }

        .fav-btn.delete:hover {
            color: var(--danger);
        }

        .toast-popup {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-100%);
            background: rgba(30, 30, 30, 0.9);
            backdrop-filter: blur(8px);
            color: white;
            padding: 12px 24px;
            border-radius: 50px;
            font-size: 15px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
            opacity: 0;
            pointer-events: none;
            transition: 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 9999;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .toast-popup.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        @media (max-width: 768px) {
            .nav-arrow {
                width: 40px;
                height: 40px;
            }

            .nav-arrow.left {
                left: 10px;
            }

            .nav-arrow.right {
                right: 10px;
            }

            .chip-container {
                padding: 0 0px;
            }
        }

        .help-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .help-modal-overlay.active {
            display: flex;
            opacity: 1;
        }

        .help-modal {
            background: var(--surface);
            color: var(--text-main);
            width: 90%;
            max-width: 500px;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            transform: scale(0.9);
            transition: transform 0.3s;
            position: relative;
            max-height: 80vh;
            overflow-y: auto;
        }

        .help-modal-overlay.active .help-modal {
            transform: scale(1);
        }

        .help-title {
            font-size: 20px;
            font-weight: 800;
            margin-bottom: 16px;
            border-bottom: 1px solid var(--border);
            padding-bottom: 10px;
        }

        .help-content {
            font-size: 14px;
            line-height: 1.6;
            color: var(--text-sub);
        }

        .help-note {
            margin-top: 6px;
            font-size: 12px;
            color: var(--text-sub);
        }

        .help-list {
            margin: 0;
            padding-left: 18px;
        }

        .help-list li {
            margin-bottom: 6px;
        }

        .inline-chip-label,
        .inline-capsule-label,
        .inline-key {
            display: inline-flex;
            align-items: center;
            padding: 0 8px;
            border-radius: 999px;
            font-size: 12px;
            font-weight: 600;
            background: var(--surface-hover);
            color: var(--text-main);
        }

        .inline-chip-label {
            background: rgba(94, 156, 126, 0.15);
        }

        .inline-capsule-label {
            background: rgba(52, 152, 219, 0.2);
        }

        .inline-key {
            font-variant: small-caps;
            letter-spacing: 0.5px;
        }

        .help-content h3 {
            color: var(--text-main);
            margin: 16px 0 8px 0;
            font-size: 16px;
        }

        .help-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: transparent;
            border: none;
            font-size: 24px;
            color: var(--text-sub);
            cursor: pointer;
        }

        .help-btn {
            background: var(--surface);
            color: var(--text-sub);
            border: 1px solid var(--border);
            width: 24px;
            height: 24px;
            border-radius: 50%;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            margin-left: 8px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: 0.2s;
        }

        .help-btn:hover {
            background: var(--highlight);
            color: white;
            border-color: var(--highlight);
        }
    </style>
</head>

<body>
    <div class="app-shell">
        <header class="app-header">
            <div class="branding">
                <h1 class="app-title">Promit</h1>
                <span class="app-version">V1.0</span><button class="help-btn" type="button"
                    aria-label="Help">?</button>
            </div>
            <div class="header-actions">
                <div class="language-dropdown">
                    <button class="icon-btn" id="languageBtn" type="button"
                        aria-expanded="false">üåê</button>
                    <div class="language-menu" id="languageMenu"></div>
                </div>
                <div class="settings-dropdown">
                    <button class="icon-btn" id="settingsBtn" type="button"
                        aria-label="Open settings" aria-expanded="false">‚öôÔ∏è</button>
                    <div class="settings-menu" id="settingsMenu">
                        <div class="settings-row theme-toggle">
                            <span id="themeToggleIcon" style="font-size:16px;">üåô</span>
                            <div class="theme-toggle-switch"></div>
                        </div>
                        <div class="settings-divider"></div>
                        <button type="button" data-setting="export">üíæ
                            <span class="settings-label">Save File</span></button>
                        <button type="button" data-setting="import">üìÇ
                            <span class="settings-label">Open File</span></button>
                        <div class="settings-divider"></div>
                        <button type="button" data-setting="reset">‚Ü∫ <span
                                class="settings-label">Reset app</span></button>
                    </div>
                </div>
            </div>
        </header>

        <div class="capsule-area" id="capsuleContainer"></div>

        <div class="editor-area">
            <div class="editor-card" id="editorContainer">
                <div class="editor-header">
                    <div class="active-fav-wrapper">
                        <div id="activeFavoriteLabel" class="active-fav-label" tabindex="0" role="button"></div>
                        <button type="button" class="active-fav-edit-btn" id="activeFavEditBtn"
                            aria-label="Edit favorite" title="Edit favorite">
                            <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M14.586 4.414a2 2 0 012.828 0l1.172 1.172a2 2 0 010 2.828L10 17l-3.9.26.26-3.9 8.226-8.226z"
                                    stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round" />
                                <path d="M4 20h16" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
                            </svg>
                        </button>
                    </div>
                    <button class="btn-fav btn-fav-top" type="button"
                        aria-label="Add to Favorites"><svg fill="currentColor" viewBox="-1 0 19 19"
                            xmlns="http://www.w3.org/2000/svg" style="width: 24px; height: 24px;">
                            <path
                                d="m12.673 10.779.798 4.02c.221 1.11-.407 1.566-1.395 1.013L8.5 13.81l-3.576 2.002c-.988.553-1.616.097-1.395-1.013l.397-2.001.401-2.02-1.51-1.397-1.498-1.385c-.832-.769-.592-1.507.532-1.64l2.026-.24 2.044-.242 1.717-3.722c.474-1.028 1.25-1.028 1.724 0l1.717 3.722 2.044.242 2.026.24c1.124.133 1.364.871.533 1.64L14.184 9.38z">
                            </path>
                        </svg></button>
                </div>
                <div id="chipContainer" class="chip-container"></div>
                <div id="popover" class="popover"></div>
                <div class="footer">
                    <div class="nav-row">
                        <div class="chip-trash" id="chipTrashArea" role="button"><span
                                class="trash-icon">üóë</span></div>
                        <div class="nav-controls">
                            <button class="nav-arrow left" type="button" id="btnPrev"
                                aria-label="Previous History">‚ùÆ</button>
                            <button class="btn btn-gen" aria-label="Roll & Generate">
                                <span class="dice-icon">üé≤</span>
                            </button>
                            <button class="nav-arrow right" type="button" id="btnNext"
                                aria-label="Next History">‚ùØ</button>
                        </div>
                        <div class="copy-controls">
                            <button class="btn-auto-copy" type="button"
                                aria-pressed="false">
                                <span class="auto-badge">AUTO</span>
                                <svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg" fill="none">
                                    <g stroke-width="0"></g>
                                    <g stroke-linecap="round" stroke-linejoin="round"></g>
                                    <g>
                                        <path fill="currentColor" fill-rule="evenodd"
                                            d="M4 2a2 2 0 00-2 2v9a2 2 0 002 2h2v2a2 2 0 002 2h9a2 2 0 002-2V8a2 2 0 00-2-2h-2V4a2 2 0 00-2-2H4zm9 4V4H4v9h2V8a2 2 0 012-2h5zM8 8h9v9H8V8z">
                                        </path>
                                    </g>
                                </svg>
                            </button>
                            <button class="btn btn-copy" type="button"
                                aria-label="Copy Prompt">
                                <svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg" fill="none"
                                    style="width: 20px; height: 20px;">
                                    <g stroke-width="0"></g>
                                    <g stroke-linecap="round" stroke-linejoin="round"></g>
                                    <g>
                                        <path fill="currentColor" fill-rule="evenodd"
                                            d="M4 2a2 2 0 00-2 2v9a2 2 0 002 2h2v2a2 2 0 002 2h9a2 2 0 002-2V8a2 2 0 00-2-2h-2V4a2 2 0 00-2-2H4zm9 4V4H4v9h2V8a2 2 0 012-2h5zM8 8h9v9H8V8z">
                                        </path>
                                    </g>
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="dock-section" id="dockSection">
            <div class="dock-tabs">
                <button class="dock-tab active" type="button" data-tab="favorites"><span class="dock-tab-label"
                        data-tab-label="favorites">‚≠ê Favorites</span> <span id="favCount"
                        style="font-size:12px; color:var(--text-sub); font-weight:600;">(0)</span></button>
                <button class="dock-tab" type="button" data-tab="history"><span class="dock-tab-label"
                        data-tab-label="history">‚è± History</span>
                    <span id="historyCount"
                        style="font-size:12px; color:var(--text-sub); font-weight:600;">(0)</span></button>
                <div class="dock-actions">
                    <button class="dock-clear-history" id="dockClearHistory" type="button">üóë</button>
                    <span class="dock-mode-indicator" id="dockDeleteBadge" style="display:none;">Delete Mode</span>
                </div>
            </div>
            <div class="dock-list" id="dockList"></div>
        </div>
        <div id="toast" class="toast-popup"></div>
    </div>
    <script>
        const Palette = [
            "#FFB7B2", "#FFDAC1", "#E2F0CB", "#B5EAD7", "#C7CEEA",
            "#F8C8DC", "#D5AAFF", "#97C1A9", "#E5E4E2", "#FF9AA2",
            "#B5B9FF", "#85E3FF", "#FFD3B6", "#A0E7E5", "#FBE7C6",
            "#D9D9D9", "#FFA384", "#74BDCB", "#EFE1CE", "#F9F871"
        ];
        const LOCALE_ORDER = ['en', 'ko', 'ja', 'zh'];
        const LOCALES = {
            en: {
                nativeName: 'English',
                strings: {
                    helpTitle: 'üí° How to Use',
                    helpContent: `<h3>1. Build Your Prompt</h3>
<ul class="help-list">
<li><span class="inline-capsule-label">CAPSULE</span> Click or drag & drop from the top bar to add chips anywhere.</li>
<li><span class="inline-chip-label">CHIP</span> Drag to reorder or insert between others; drop onto the üóë zone to delete.</li>
<li>Tap a chip to edit options, long-press any entry to rename or clear it.</li>
<li>Tap the chip's üé≤ icon to lock it as a üîí so it won't roll.</li>
<li>Click between chips to link or unlink them (switching between space and comma output).</li>
</ul>
<h3>2. Generate & Copy</h3>
<ul class="help-list">
<li>üé≤ rolls only the chips marked as random and builds the prompt.</li>
<li><strong>Auto Copy</strong> instantly copies every roll to your clipboard.</li>
</ul>
<h3>3. Favorites & History</h3>
<ul class="help-list">
<li>‚≠ê Favorites work like drop-in presets: drag a favorite chip onto the board to insert its combo, or tap to load it entirely.</li>
<li>‚è± History lets you revisit recent rolls. Use <span class="inline-key">Ctrl+Z / Ctrl+Shift+Z</span> or the arrows beside üé≤.</li>
<li>Long-press a favorite chip to rename or delete it.</li>
</ul>
<h3>4. Edit or Delete</h3>
<ul class="help-list">
<li>Drag any chip onto the üóë delete zone to remove it.</li>
<li>Long-press a capsule for ~2 seconds to rename or delete it.</li>
</ul>
<h3>5. Save & Load</h3>
<ul class="help-list">
<li><strong>Save File</strong> exports all of your prompt data (everything except roll history) as a JSON backup.</li>
<li><strong>Open File</strong> restores a JSON that was saved from this app.</li>
</ul>`,
                    chipEmptyState: 'üëÜ Tap or drag capsules above to add chips.',
                    favoritesEmpty: 'No favorites yet.',
                    historyEmpty: 'No roll history yet.',
                    popoverRandom: 'üé≤ Random',
                    popoverAddPlaceholder: '+ Add & Select...',
                    toastFavoritesAdded: '‚≠ê Added to favorites!',
                    toastFavoriteExists: '‚ö†Ô∏è Already in favorites.',
                    toastFavoriteApplied: '‚úÖ Favorite applied!',
                    toastFavoriteDeleted: 'üóëÔ∏è Favorite removed.',
                    toastFavoriteRestored: '‚Ü©Ô∏è Favorite restored.',
                    toastRollRestored: '‚è™ Roll restored',
                    toastCopy: '‚úÖ Copied to clipboard!',
                    toastCopyShort: '‚úÖ Copied!',
                    toastAutoCopyOn: '‚ö° Auto copy ON',
                    toastAutoCopyOff: '‚úã Auto copy OFF',
                    toastReset: 'üîÑ All data reset',
                    toastRollHistoryCleared: 'üßπ Roll history cleared',
                    toastPromptCopied: '‚ö° Prompt copied!',
                    toastFavoriteRenamed: '‚úèÔ∏è Favorite renamed.',
                    toastCapRenamed: '‚úèÔ∏è Capsule name updated.',
                    toastCapDeleted: 'üóëÔ∏è Capsule deleted.',
                    toastImportSuccess: 'üì• Favorites imported!',
                    alertEmptyPrompt: 'Prompt is empty.',
                    confirmReset: 'Reset all data?',
                    confirmClearHistory: 'Clear all roll history?',
                    newTagPrompt: 'New tag name:',
                    dockDeleteBadge: 'Delete Mode',
                    settingsSave: 'Save File',
                    settingsOpen: 'Open File',
                    settingsReset: 'Reset app',
                    btnFavAria: 'Add to favorites',
                    btnGenerateAria: 'Roll & Generate',
                    btnCopyAria: 'Copy prompt',
                    btnPrevAria: 'Previous history',
                    btnNextAria: 'Next history',
                    btnAutoCopyAria: 'Toggle auto copy',
                    chipTrashHint: 'Drop chips here to delete',
                    settingsAria: 'Open settings',
                    languageAria: 'Change language',
                    helpAria: 'Help',
                    emptyPromptPreview: '(Empty prompt)',
                    chipLinkOn: 'Linked',
                    chipLinkOff: 'Link',
                    chipUnlink: 'Unlink',
                    capEditTitle: 'Rename',
                    capEditHint: '(Blank to delete)',
                    confirmLabel: 'Confirm',
                    deleteLabel: 'Delete',
                    cancelLabel: 'Cancel',
                    importError: 'Error: ',
                    historyTab: '‚è± History',
                    favoritesTab: '‚≠ê Favorites',
                    favoriteNamePrefix: 'Fav',
                    favEditTitle: 'Rename',
                    favEditHint: '(Blank to delete)',
                    cancelLabel: 'Cancel'
                }
            },
            ko: {
                nativeName: 'ÌïúÍµ≠Ïñ¥',
                strings: {
                    helpTitle: 'üí° ÏÇ¨Ïö© Î∞©Î≤ï',
                    helpContent: `<h3>1. ÌîÑÎ°¨ÌîÑÌä∏ Íµ¨ÏÑ±ÌïòÍ∏∞</h3>
<ul class="help-list">
<li><span class="inline-capsule-label">Ï∫°Ïäê</span>ÏùÑ ÌÅ¥Î¶≠ÌïòÍ±∞ÎÇò ÎìúÎûòÍ∑∏&ÎìúÎ°≠ÌïòÏó¨ ÏûêÏú†Î°≠Í≤å Ïπ©ÏùÑ Ï∂îÍ∞ÄÌïòÏÑ∏Ïöî.</li>
<li><span class="inline-chip-label">Ïπ©</span>ÏùÄ ÏõêÌïòÎäî ÏúÑÏπòÏóê ÎÅºÏõå ÎÑ£Í±∞ÎÇò ÏàúÏÑúÎ•º ÎßàÏùåÎåÄÎ°ú Î∞îÍøÄ Ïàò ÏûàÏäµÎãàÎã§.</li>
<li>Ïπ©ÏùÑ ÌÅ¥Î¶≠ÌïòÎ©¥ ÏôÄÏùºÎìúÏπ¥Îìú Î™©Î°ùÏùÑ Ï∂îÍ∞Ä¬∑ÏàòÏ†ïÌï† Ïàò ÏûàÍ≥†, üóë Ìú¥ÏßÄÌÜµÏúºÎ°ú ÎìúÎûòÍ∑∏ÌïòÎ©¥ ÏÇ≠Ï†úÎê©ÎãàÎã§.</li>
<li>Ïπ© ÏïûÏùò üé≤ ÏïÑÏù¥ÏΩòÏùÑ ÎàåÎü¨ üîí Î°ú Ï†ÑÌôòÌïòÎ©¥ Ìï¥Îãπ Ïπ©ÏùÑ Í≥†Ï†ïÌï©ÎãàÎã§.</li>
<li>Ïπ© ÏÇ¨Ïù¥Î•º ÌÅ¥Î¶≠ÌïòÎ©¥ Ïó∞Í≤∞/Ìï¥Ï†úÍ∞Ä ÎêòÏñ¥ ÎùÑÏñ¥Ïì∞Í∏∞ÏôÄ ÏΩ§Îßà Ï∂úÎ†• Î∞©ÏãùÏùÑ Î∞îÍøÄ Ïàò ÏûàÏäµÎãàÎã§.</li>
</ul>
<h3>2. ÏÉùÏÑ±Í≥º Î≥µÏÇ¨</h3>
<ul class="help-list">
<li>üé≤ Î≤ÑÌäºÏùÄ ÎûúÎç§ ÏÉÅÌÉú(üé≤)Ïù∏ Ïπ©Îßå Íµ¥Î†§ÏÑú ÌîÑÎ°¨ÌîÑÌä∏Î•º ÎßåÎì≠ÎãàÎã§.</li>
<li><strong>Auto Copy</strong>Î•º ÏºúÎëêÎ©¥ Îß§Î≤à ÏûêÎèôÏúºÎ°ú ÌÅ¥Î¶ΩÎ≥¥ÎìúÏóê Î≥µÏÇ¨Îê©ÎãàÎã§.</li>
</ul>
<h3>3. Ï¶êÍ≤®Ï∞æÍ∏∞ & Í∏∞Î°ù Î≥µÍµ¨</h3>
<ul class="help-list">
<li>‚≠ê Ï¶êÍ≤®Ï∞æÍ∏∞Îäî Ïπ©ÏùÑ ÎìúÎûòÍ∑∏Ìï¥ ÏõêÌïòÎäî ÏúÑÏπòÏóê ÎÅºÏõåÎÑ£ÏùÑ Ïàò ÏûàÎäî ÌîÑÎ¶¨ÏÖãÏù¥Î©∞, ÌÉ≠ÌïòÎ©¥ Ï†ÑÏ≤¥Î•º Î∂àÎü¨ÏòµÎãàÎã§.</li>
<li>‚è± ÌûàÏä§ÌÜ†Î¶¨ÏóêÏÑúÎäî Ïù¥Ï†Ñ Îã§Ïù¥Ïä§ Í∞íÏùÑ ÌôïÏù∏Ìï† Ïàò ÏûàÏúºÎ©∞ <span class="inline-key">Ctrl+Z / Ctrl+Shift+Z</span> ÎòêÎäî üé≤ Ïñë ÏòÜÏùò ÌôîÏÇ¥ÌëúÎ°ú Ïù¥ÎèôÌï† Ïàò ÏûàÏäµÎãàÎã§.</li>
</ul>
<h3>4. ÏÇ≠Ï†ú ÎòêÎäî ÏàòÏ†ï</h3>
<ul class="help-list">
<li>Ïπ©ÏùÄ üóë Ìú¥ÏßÄÌÜµ ÏòÅÏó≠ÏúºÎ°ú ÎìúÎûòÍ∑∏ÌïòÎ©¥ Ï¶âÏãú ÏÇ≠Ï†úÎê©ÎãàÎã§.</li>
<li>Ï∫°ÏäêÏùÑ ÏïΩ 2Ï¥àÍ∞Ñ Í∏∏Í≤å ÎàåÎü¨ Ïù¥Î¶ÑÏùÑ Î∞îÍæ∏Í±∞ÎÇò ÏÇ≠Ï†úÌï† Ïàò ÏûàÏäµÎãàÎã§.</li>
</ul>
<h3>5. ÌååÏùº Ï†ÄÏû•¬∑Î∂àÎü¨Ïò§Í∏∞</h3>
<ul class="help-list">
<li><strong>ÌååÏùº Ï†ÄÏû•</strong>ÏùÑ ÎàÑÎ•¥Î©¥ ÌûàÏä§ÌÜ†Î¶¨Î•º Ï†úÏô∏Ìïú Î™®Îì† Îç∞Ïù¥ÌÑ∞Î•º JSONÏúºÎ°ú ÎÇ¥Î≥¥ÎÇº Ïàò ÏûàÏäµÎãàÎã§.</li>
<li><strong>ÌååÏùº Ïó¥Í∏∞</strong>Îäî Ïù¥ Ïï±ÏóêÏÑú Ï†ÄÏû•Ìïú JSONÏùÑ Îã§Ïãú Î∂àÎü¨ÏòµÎãàÎã§.</li>
</ul>`,
                    chipEmptyState: 'üëÜ ÏÉÅÎã®Ïùò Ï∫°ÏäêÏùÑ ÌÅ¥Î¶≠ÌïòÍ±∞ÎÇò ÎìúÎûòÍ∑∏ÌïòÏó¨ Ï∂îÍ∞ÄÌïòÏÑ∏Ïöî.',
                    favoritesEmpty: 'Ï¶êÍ≤®Ï∞æÍ∏∞Í∞Ä ÏóÜÏäµÎãàÎã§.',
                    historyEmpty: 'ÌûàÏä§ÌÜ†Î¶¨ ÎÇ¥Ïó≠Ïù¥ ÏóÜÏäµÎãàÎã§.',
                    popoverRandom: 'üé≤ ÎûúÎç§',
                    popoverAddPlaceholder: '+ ÏßÅÏ†ë Ï∂îÍ∞Ä ÌõÑ ÏÑ†ÌÉù...',
                    toastFavoritesAdded: '‚≠ê Ï¶êÍ≤®Ï∞æÍ∏∞Ïóê Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§!',
                    toastFavoriteExists: '‚ö†Ô∏è Ïù¥ÎØ∏ Ï¶êÍ≤®Ï∞æÍ∏∞Ïóê ÏûàÏäµÎãàÎã§.',
                    toastFavoriteApplied: '‚úÖ Ï¶êÍ≤®Ï∞æÍ∏∞Í∞Ä Ï†ÅÏö©ÎêòÏóàÏäµÎãàÎã§!',
                    toastFavoriteDeleted: 'üóëÔ∏è Ï¶êÍ≤®Ï∞æÍ∏∞Í∞Ä ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.',
                    toastFavoriteRestored: '‚Ü©Ô∏è Ï¶êÍ≤®Ï∞æÍ∏∞Î•º Î≥µÏõêÌñàÏäµÎãàÎã§.',
                    toastRollRestored: '‚è™ ÌûàÏä§ÌÜ†Î¶¨Î•º Î≥µÏõêÌñàÏäµÎãàÎã§.',
                    toastCopy: '‚úÖ Î≥µÏÇ¨ÎêòÏóàÏäµÎãàÎã§!',
                    toastCopyShort: '‚úÖ Î≥µÏÇ¨ ÏôÑÎ£å!',
                    toastAutoCopyOn: '‚ö° ÏûêÎèô Î≥µÏÇ¨ ON',
                    toastAutoCopyOff: '‚úã ÏûêÎèô Î≥µÏÇ¨ OFF',
                    toastReset: 'üîÑ Î™®Îì† Îç∞Ïù¥ÌÑ∞Í∞Ä Ï¥àÍ∏∞ÌôîÎêòÏóàÏäµÎãàÎã§.',
                    toastRollHistoryCleared: 'üßπ ÌûàÏä§ÌÜ†Î¶¨Î•º Î™®Îëê ÏÇ≠Ï†úÌñàÏäµÎãàÎã§.',
                    toastPromptCopied: '‚ö° ÌîÑÎ°¨ÌîÑÌä∏Î•º Î≥µÏÇ¨ÌñàÏäµÎãàÎã§!',
                    toastFavoriteRenamed: '‚úèÔ∏è Ï¶êÍ≤®Ï∞æÍ∏∞ Ïù¥Î¶ÑÏùÑ Î≥ÄÍ≤ΩÌñàÏäµÎãàÎã§.',
                    toastCapRenamed: '‚úèÔ∏è Ï∫°Ïäê Ïù¥Î¶ÑÏù¥ Î≥ÄÍ≤ΩÎêòÏóàÏäµÎãàÎã§.',
                    toastCapDeleted: 'üóëÔ∏è Ï∫°ÏäêÏù¥ ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.',
                    toastImportSuccess: 'üì• Ï¶êÍ≤®Ï∞æÍ∏∞ Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨ÏôîÏäµÎãàÎã§.',
                    alertEmptyPrompt: 'ÎÇ¥Ïö©Ïù¥ ÎπÑÏñ¥ÏûàÏäµÎãàÎã§.',
                    confirmReset: 'Î™®Îì† Îç∞Ïù¥ÌÑ∞Î•º Ï¥àÍ∏∞ÌôîÌïòÏãúÍ≤†ÏäµÎãàÍπå?',
                    confirmClearHistory: 'ÌûàÏä§ÌÜ†Î¶¨Î•º Î™®Îëê ÏÇ≠Ï†úÌï†ÍπåÏöî?',
                    newTagPrompt: 'ÏÉàÎ°úÏö¥ ÌÉúÍ∑∏ Ïù¥Î¶Ñ:',
                    dockDeleteBadge: 'ÏÇ≠Ï†ú Î™®Îìú',
                    settingsSave: 'ÌååÏùº Ï†ÄÏû•',
                    settingsOpen: 'ÌååÏùº Ïó¥Í∏∞',
                    settingsReset: 'Ïï± Ï¥àÍ∏∞Ìôî',
                    btnFavAria: 'Ï¶êÍ≤®Ï∞æÍ∏∞ Ï∂îÍ∞Ä',
                    btnGenerateAria: 'Íµ¥Î¶¨Í∏∞ & ÏÉùÏÑ±',
                    btnCopyAria: 'ÌîÑÎ°¨ÌîÑÌä∏ Î≥µÏÇ¨',
                    btnPrevAria: 'Ïù¥Ï†Ñ ÌûàÏä§ÌÜ†Î¶¨',
                    btnNextAria: 'Îã§Ïùå ÌûàÏä§ÌÜ†Î¶¨',
                    btnAutoCopyAria: 'ÏûêÎèô Î≥µÏÇ¨ ÌÜ†Í∏Ä',
                    chipTrashHint: 'Ïπ©ÏùÑ Ïù¥Í≥≥ÏúºÎ°ú ÎìúÎûòÍ∑∏ÌïòÎ©¥ ÏÇ≠Ï†úÎê©ÎãàÎã§',
                    settingsAria: 'ÏÑ§Ï†ï Ïó¥Í∏∞',
                    languageAria: 'Ïñ∏Ïñ¥ Î≥ÄÍ≤Ω',
                    helpAria: 'ÎèÑÏõÄÎßê',
                    emptyPromptPreview: '(Îπà ÌîÑÎ°¨ÌîÑÌä∏)',
                    chipLinkOn: 'Ïó∞Í≤∞Îê®',
                    chipLinkOff: 'Ïó∞Í≤∞',
                    chipUnlink: 'Ïó∞Í≤∞ Ìï¥Ï†ú',
                    capEditTitle: 'Ïù¥Î¶Ñ Î≥ÄÍ≤Ω',
                    capEditHint: '(Í≥µÎ∞±Ïù¥Î©¥ ÏÇ≠Ï†ú)',
                    confirmLabel: 'ÌôïÏù∏',
                    deleteLabel: 'ÏÇ≠Ï†ú',
                    cancelLabel: 'Ï∑®ÏÜå',
                    importError: 'Ïò§Î•ò: ',
                    historyTab: '‚è± ÌûàÏä§ÌÜ†Î¶¨',
                    favoritesTab: '‚≠ê Ï¶êÍ≤®Ï∞æÍ∏∞',
                    favoriteNamePrefix: 'Fav',
                    favEditTitle: 'Ïù¥Î¶Ñ Î≥ÄÍ≤Ω',
                    favEditHint: '(Í≥µÎ∞±Ïù¥Î©¥ ÏÇ≠Ï†ú)',
                    cancelLabel: 'Ï∑®ÏÜå'
                }
            },
            ja: {
                nativeName: 'Êó•Êú¨Ë™û',
                strings: {
                    helpTitle: 'üí° ‰Ωø„ÅÑÊñπ',
                    helpContent: `<h3>1. „Éó„É≠„É≥„Éó„Éà„ÇíÁµÑ„ÅøÁ´ã„Å¶„Çã</h3>
<ul class="help-list">
<li><span class="inline-capsule-label">„Ç´„Éó„Çª„É´</span>„Çí„ÇØ„É™„ÉÉ„ÇØ„Åæ„Åü„ÅØ„Éâ„É©„ÉÉ„Ç∞ÔºÜ„Éâ„É≠„ÉÉ„Éó„Åó„Å¶Ëá™Áî±„Å´„ÉÅ„ÉÉ„Éó„ÇíËøΩÂä†„Åó„Åæ„Åô„ÄÇ</li>
<li><span class="inline-chip-label">„ÉÅ„ÉÉ„Éó</span>„ÅØÂ•Ω„Åç„Å™‰ΩçÁΩÆ„Å´ÊåøÂÖ•„Åß„Åç„ÄÅÈ†ÜÁï™„ÇÇÁ∞°Âçò„Å´ÂÖ•„ÇåÊõø„Åà„Çâ„Çå„Åæ„Åô„ÄÇ</li>
<li>„ÉÅ„ÉÉ„Éó„Çí„Çø„ÉÉ„Éó„Åó„Å¶„ÉØ„Ç§„É´„Éâ„Ç´„Éº„Éâ„ÇíÁ∑®ÈõÜ„Åó„ÄÅüóëÂâäÈô§„Çæ„Éº„É≥„Å´„Éâ„É©„ÉÉ„Ç∞„Åô„Çã„Å®Âç≥ÂâäÈô§„Åß„Åç„Åæ„Åô„ÄÇ</li>
<li>„ÉÅ„ÉÉ„ÉóÊ®™„ÅÆüé≤„Çí„Çø„ÉÉ„Éó„Åó„Å¶üîí„Å´„Åô„Çã„Å®Âõ∫ÂÆö„Åß„Åç„Åæ„Åô„ÄÇ</li>
<li>„ÉÅ„ÉÉ„Éó„ÅÆÈñì„Çí„ÇØ„É™„ÉÉ„ÇØ„Åô„Çã„Å®ÈÄ£Áµê/Ëß£Èô§„Åå„Åß„Åç„ÄÅÁ©∫ÁôΩ„Å®„Ç´„É≥„Éû„ÅÆÂá∫Âäõ„ÇíÂàá„ÇäÊõø„Åà„Åæ„Åô„ÄÇ</li>
</ul>
<h3>2. ÁîüÊàê„Å®„Ç≥„Éî„Éº</h3>
<ul class="help-list">
<li>üé≤ „ÅØ„É©„É≥„ÉÄ„É†Áä∂ÊÖã„ÅÆ„ÉÅ„ÉÉ„Éó„Å†„Åë„Çí„É≠„Éº„É´„Åó„Å¶„Éó„É≠„É≥„Éó„Éà„Çí‰ΩúÊàê„Åó„Åæ„Åô„ÄÇ</li>
<li><strong>Auto Copy</strong>„Çí„Ç™„É≥„Å´„Åô„Çã„Å®ÊØéÂõûËá™Âãï„Åß„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å∏„Ç≥„Éî„Éº„Åï„Çå„Åæ„Åô„ÄÇ</li>
</ul>
<h3>3. „ÅäÊ∞ó„Å´ÂÖ•„Çä & Â±•Ê≠¥</h3>
<ul class="help-list">
<li>‚≠ê „ÅäÊ∞ó„Å´ÂÖ•„Çä„ÅØ„Éâ„É©„ÉÉ„Ç∞„Åß‰ªªÊÑè„ÅÆ‰ΩçÁΩÆ„Å´Â∑Æ„ÅóËæº„ÇÅ„Çã„Éó„É™„Çª„ÉÉ„Éà„ÄÅ„Çø„ÉÉ„Éó„ÅßÂÖ®‰Ωì„ÇíË™≠„ÅøËæº„ÇÅ„Åæ„Åô„ÄÇ</li>
<li>‚è± Â±•Ê≠¥„Åß„ÅØÁõ¥Ëøë„ÅÆ„ÉÄ„Ç§„ÇπÁµêÊûú„ÇíÁ¢∫Ë™ç„Åß„Åç„ÄÅ<span class="inline-key">Ctrl+Z / Ctrl+Shift+Z</span> „ÇÑ üé≤ „ÅÆÂ∑¶Âè≥„ÅÆÁü¢Âç∞„ÅßÈÅ°„Çå„Åæ„Åô„ÄÇ</li>
<li>„ÅäÊ∞ó„Å´ÂÖ•„Çä„ÉÅ„ÉÉ„Éó„ÇíÈï∑Êäº„Åó„Åô„Çã„Å®„É™„Éç„Éº„É†„ÇÑÂâäÈô§„Åå„Åß„Åç„Åæ„Åô„ÄÇ</li>
</ul>
<h3>4. ÂâäÈô§ / Á∑®ÈõÜ</h3>
<ul class="help-list">
<li>„ÉÅ„ÉÉ„Éó„ÅØüóëÂâäÈô§„Çæ„Éº„É≥„Å´„Éâ„É©„ÉÉ„Ç∞„Åô„Çã„Å®„Åô„Åê„Å´ÂâäÈô§„Åß„Åç„Åæ„Åô„ÄÇ</li>
<li>„Ç´„Éó„Çª„É´„ÅØÁ¥Ñ2ÁßíÈï∑Êäº„Åó„ÅßÂêçÂâçÂ§âÊõ¥„ÇÑÂâäÈô§„Åå„Åß„Åç„Åæ„Åô„ÄÇ</li>
</ul>
<h3>5. ‰øùÂ≠ò„Å®Ë™≠„ÅøËæº„Åø</h3>
<ul class="help-list">
<li><strong>„Éï„Ç°„Ç§„É´‰øùÂ≠ò</strong>„ÅØÂ±•Ê≠¥„ÇíÈô§„Åè„Åô„Åπ„Å¶„ÅÆ„Éá„Éº„Çø„ÇíJSON„ÅßÊõ∏„ÅçÂá∫„Åó„Åæ„Åô„ÄÇ</li>
<li><strong>„Éï„Ç°„Ç§„É´„ÇíÈñã„Åè</strong>„Å®„ÄÅ„Åì„ÅÆ„Ç¢„Éó„É™„Åß‰øùÂ≠ò„Åó„ÅüJSON„ÇíÂæ©ÂÖÉ„Åß„Åç„Åæ„Åô„ÄÇ</li>
</ul>`,
                    chipEmptyState: 'üëÜ ‰∏ä„ÅÆ„Ç´„Éó„Çª„É´„Çí„Çø„ÉÉ„Éó„Åæ„Åü„ÅØ„Éâ„É©„ÉÉ„Ç∞„Åó„Å¶ËøΩÂä†„Åó„Åæ„Åô„ÄÇ',
                    favoritesEmpty: '„ÅäÊ∞ó„Å´ÂÖ•„Çä„ÅØ„Åæ„Å†„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ',
                    historyEmpty: 'Â±•Ê≠¥„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ',
                    popoverRandom: 'üé≤ „É©„É≥„ÉÄ„É†',
                    popoverAddPlaceholder: '+ ËøΩÂä†„Åó„Å¶ÈÅ∏Êäû...',
                    toastFavoritesAdded: '‚≠ê „ÅäÊ∞ó„Å´ÂÖ•„Çä„Å´ËøΩÂä†„Åó„Åæ„Åó„Åü!',
                    toastFavoriteExists: '‚ö†Ô∏è „Åô„Åß„Å´ÁôªÈå≤„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ',
                    toastFavoriteApplied: '‚úÖ „ÅäÊ∞ó„Å´ÂÖ•„Çä„ÇíÈÅ©Áî®„Åó„Åæ„Åó„Åü!',
                    toastFavoriteDeleted: 'üóëÔ∏è „ÅäÊ∞ó„Å´ÂÖ•„Çä„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü„ÄÇ',
                    toastFavoriteRestored: '‚Ü©Ô∏è „ÅäÊ∞ó„Å´ÂÖ•„Çä„ÇíÂÖÉ„Å´Êàª„Åó„Åæ„Åó„Åü„ÄÇ',
                    toastRollRestored: '‚è™ Â±•Ê≠¥„ÇíÂæ©ÂÖÉ„Åó„Åæ„Åó„Åü„ÄÇ',
                    toastCopy: '‚úÖ „Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü!',
                    toastCopyShort: '‚úÖ „Ç≥„Éî„ÉºÂÆå‰∫Ü!',
                    toastAutoCopyOn: '‚ö° Ëá™Âãï„Ç≥„Éî„Éº ON',
                    toastAutoCopyOff: '‚úã Ëá™Âãï„Ç≥„Éî„Éº OFF',
                    toastReset: 'üîÑ „Åô„Åπ„Å¶ÂàùÊúüÂåñ„Åó„Åæ„Åó„Åü„ÄÇ',
                    toastRollHistoryCleared: 'üßπ Â±•Ê≠¥„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü„ÄÇ',
                    toastPromptCopied: '‚ö° „Éó„É≠„É≥„Éó„Éà„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü!',
                    toastFavoriteRenamed: '‚úèÔ∏è „ÅäÊ∞ó„Å´ÂÖ•„ÇäÂêç„ÇíÂ§âÊõ¥„Åó„Åæ„Åó„Åü„ÄÇ',
                    toastCapRenamed: '‚úèÔ∏è „Ç´„Éó„Çª„É´Âêç„ÇíÂ§âÊõ¥„Åó„Åæ„Åó„Åü„ÄÇ',
                    toastCapDeleted: 'üóëÔ∏è „Ç´„Éó„Çª„É´„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü„ÄÇ',
                    toastImportSuccess: 'üì• „ÅäÊ∞ó„Å´ÂÖ•„Çä„ÇíË™≠„ÅøËæº„Åø„Åæ„Åó„Åü„ÄÇ',
                    alertEmptyPrompt: 'ÂÜÖÂÆπ„ÅåÁ©∫„Åß„Åô„ÄÇ',
                    confirmReset: '„Éá„Éº„Çø„ÇíÂàùÊúüÂåñ„Åó„Åæ„Åô„ÅãÔºü',
                    confirmClearHistory: 'Â±•Ê≠¥„Çí„Åô„Åπ„Å¶ÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü',
                    newTagPrompt: 'Êñ∞„Åó„ÅÑ„Çø„Ç∞Âêç:',
                    dockDeleteBadge: 'ÂâäÈô§„É¢„Éº„Éâ',
                    settingsSave: '„Éï„Ç°„Ç§„É´‰øùÂ≠ò',
                    settingsOpen: '„Éï„Ç°„Ç§„É´„ÇíÈñã„Åè',
                    settingsReset: '„Ç¢„Éó„É™ÂàùÊúüÂåñ',
                    btnFavAria: '„ÅäÊ∞ó„Å´ÂÖ•„Çä„Å´ËøΩÂä†',
                    btnGenerateAria: '„É≠„Éº„É´„Åó„Å¶ÁîüÊàê',
                    btnCopyAria: '„Éó„É≠„É≥„Éó„Éà„Çí„Ç≥„Éî„Éº',
                    btnPrevAria: 'Ââç„ÅÆÂ±•Ê≠¥',
                    btnNextAria: 'Ê¨°„ÅÆÂ±•Ê≠¥',
                    btnAutoCopyAria: 'Ëá™Âãï„Ç≥„Éî„ÉºÂàáÊõø',
                    chipTrashHint: '„Åì„Åì„Å´„Éâ„É©„ÉÉ„Ç∞„Åó„Å¶„ÉÅ„ÉÉ„Éó„ÇíÂâäÈô§',
                    settingsAria: 'Ë®≠ÂÆö„ÇíÈñã„Åè',
                    languageAria: 'Ë®ÄË™û„ÇíÂ§âÊõ¥',
                    helpAria: '„Éò„É´„Éó',
                    emptyPromptPreview: '(Á©∫„ÅÆ„Éó„É≠„É≥„Éó„Éà)',
                    chipLinkOn: 'ÈÄ£Áµê‰∏≠',
                    chipLinkOff: 'ÈÄ£Áµê',
                    chipUnlink: 'ÈÄ£ÁµêËß£Èô§',
                    capEditTitle: 'ÂêçÂâç„ÇíÂ§âÊõ¥',
                    capEditHint: '(Á©∫Ê¨Ñ„ÅßÂâäÈô§)',
                    confirmLabel: 'Ê±∫ÂÆö',
                    deleteLabel: 'ÂâäÈô§',
                    cancelLabel: '„Ç≠„É£„É≥„Çª„É´',
                    importError: '„Ç®„É©„Éº: ',
                    historyTab: '‚è± Â±•Ê≠¥',
                    favoritesTab: '‚≠ê „ÅäÊ∞ó„Å´ÂÖ•„Çä',
                    favoriteNamePrefix: 'Fav',
                    favEditTitle: '„ÅäÊ∞ó„Å´ÂÖ•„ÇäÂêç',
                    favEditHint: '(Á©∫Ê¨Ñ„ÅßÂâäÈô§)',
                    cancelLabel: '„Ç≠„É£„É≥„Çª„É´'
                }
            },
            zh: {
                nativeName: '‰∏≠Êñá',
                strings: {
                    helpTitle: 'üí° ‰ΩøÁî®ËØ¥Êòé',
                    helpContent: `<h3>1. ÊûÑÂª∫ÊèêÁ§∫ËØç</h3>
<ul class="help-list">
<li><span class="inline-capsule-label">ËÉ∂Âõä</span>ÂèØÁÇπÂáªÊàñÊãñÊîæÊù•ÈöèÊÑèÊ∑ªÂä†Á≠πÁ†Å„ÄÇ</li>
<li><span class="inline-chip-label">Á≠πÁ†Å</span>ËÉΩÊèíÂÖ•Âà∞‰ªªÊÑè‰ΩçÁΩÆÂπ∂ÈáçÊñ∞ÊéíÂ∫èÔºåÊãñÂà∞üóëÂà†Èô§Âå∫ÂüüÂç≥ÂèØÂø´ÈÄüÂà†Èô§„ÄÇ</li>
<li>ÁÇπÂáªÁ≠πÁ†ÅÂèØÁºñËæëÈÄâÈ°πÔºåÈïøÊåâÊù°ÁõÆÂèØÈáçÂëΩÂêçÔºåÁïôÁ©∫Âç≥ÂèØÂà†Èô§„ÄÇ</li>
<li>ÁÇπÂáªÁ≠πÁ†ÅÂâçÁöÑ üé≤ Â∞ÜÂÖ∂ÂàáÊç¢‰∏∫ üîíÔºåÂç≥ÂèØÂõ∫ÂÆöËØ•Á≠πÁ†Å„ÄÇ</li>
<li>ÁÇπÂáªÁ≠πÁ†Å‰πãÈó¥ÂèØËøûÊé•/Êñ≠ÂºÄÔºåÁî®Êù•ÂàáÊç¢Á©∫Ê†ºÊàñÈÄóÂè∑ËæìÂá∫„ÄÇ</li>
</ul>
<h3>2. ÁîüÊàê‰∏éÂ§çÂà∂</h3>
<ul class="help-list">
<li>üé≤ Âè™‰ºöÊé∑Âá∫Ê†áËÆ∞‰∏∫ÈöèÊú∫ÁöÑÁ≠πÁ†ÅÂπ∂ÁîüÊàêÊèêÁ§∫ËØç„ÄÇ</li>
<li><strong>Auto Copy</strong> ÊâìÂºÄÂêéÔºåÊØèÊ¨°ÈÉΩ‰ºöËá™Âä®Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø„ÄÇ</li>
</ul>
<h3>3. Êî∂Ëóè‰∏éÂéÜÂè≤</h3>
<ul class="help-list">
<li>‚≠ê Êî∂Ëóè ÊòØÂèØÊãñÊîæÁöÑÈ¢ÑËÆæÔºöÊãñÂà∞ÁºñËæëÂå∫ÊèíÂÖ•Â±ÄÈÉ®ÔºåÁÇπÂáªÂèØÁõ¥Êé•Â•óÁî®Êï¥Â•ó„ÄÇ</li>
<li>‚è± ÂéÜÂè≤ ÂèØ‰ª•Êü•Áúã‰πãÂâçÁöÑÊé∑È™∞ÁªìÊûúÔºåÂèØÁî® <span class="inline-key">Ctrl+Z / Ctrl+Shift+Z</span> Êàñ üé≤ ‰∏§‰æßÁöÑÁÆ≠Â§¥ÊµèËßà„ÄÇ</li>
<li>ÈïøÊåâÊî∂ËóèÁ≠πÁ†ÅÂç≥ÂèØÈáçÂëΩÂêçÊàñÂà†Èô§„ÄÇ</li>
</ul>
<h3>4. Âà†Èô§ÊàñÁºñËæë</h3>
<ul class="help-list">
<li>Â∞ÜÁ≠πÁ†ÅÊãñÂà∞üóëÂà†Èô§Âå∫Âç≥ÂèØÁ´ãÂàªÁßªÈô§„ÄÇ</li>
<li>ÈïøÊåâËÉ∂ÂõäÁ∫¶2ÁßíÂèØÈáçÂëΩÂêçÊàñÂà†Èô§„ÄÇ</li>
</ul>
<h3>5. ‰øùÂ≠ò‰∏éËØªÂèñ</h3>
<ul class="help-list">
<li><strong>‰øùÂ≠òÊñá‰ª∂</strong>‰ºöÂ∞ÜÈô§ÂéÜÂè≤ËÆ∞ÂΩï‰ª•Â§ñÁöÑÂÖ®ÈÉ®Êï∞ÊçÆÂØºÂá∫‰∏∫ JSONÔºå‰æø‰∫éÂ§á‰ªΩ„ÄÇ</li>
<li><strong>ÊâìÂºÄÊñá‰ª∂</strong>Áî®‰∫éÂä†ËΩΩ‰ªéÊú¨Â∫îÁî®‰øùÂ≠òÁöÑ JSON„ÄÇ</li>
</ul>`,
                    chipEmptyState: 'üëÜ ÁÇπÂáªÊàñÊãñÂä®‰∏äÊñπËÉ∂ÂõäÊù•Ê∑ªÂä†Á≠πÁ†Å„ÄÇ',
                    favoritesEmpty: 'ÊöÇÊó†Êî∂Ëóè„ÄÇ',
                    historyEmpty: 'ÊöÇÊó†ÂéÜÂè≤ËÆ∞ÂΩï„ÄÇ',
                    popoverRandom: 'üé≤ ÈöèÊú∫',
                    popoverAddPlaceholder: '+ ËæìÂÖ•Âπ∂ÈÄâÊã©...',
                    toastFavoritesAdded: '‚≠ê Â∑≤Âä†ÂÖ•Êî∂ËóèÔºÅ',
                    toastFavoriteExists: '‚ö†Ô∏è Â∑≤ÁªèÂú®Êî∂ËóèÂàóË°®‰∏≠„ÄÇ',
                    toastFavoriteApplied: '‚úÖ Â∑≤Â∫îÁî®Êî∂ËóèÔºÅ',
                    toastFavoriteDeleted: 'üóëÔ∏è Â∑≤Âà†Èô§Êî∂Ëóè„ÄÇ',
                    toastFavoriteRestored: '‚Ü©Ô∏è Êî∂ËóèÂ∑≤ÊÅ¢Â§ç„ÄÇ',
                    toastRollRestored: '‚è™ Â∑≤ÊÅ¢Â§çÂéÜÂè≤„ÄÇ',
                    toastCopy: '‚úÖ Â∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥ÊùøÔºÅ',
                    toastCopyShort: '‚úÖ Â∑≤Â§çÂà∂ÔºÅ',
                    toastAutoCopyOn: '‚ö° Ëá™Âä®Â§çÂà∂Â∑≤ÂºÄÂêØ',
                    toastAutoCopyOff: '‚úã Ëá™Âä®Â§çÂà∂Â∑≤ÂÖ≥Èó≠',
                    toastReset: 'üîÑ Êï∞ÊçÆÂ∑≤ÈáçÁΩÆ„ÄÇ',
                    toastRollHistoryCleared: 'üßπ ÂéÜÂè≤ËÆ∞ÂΩïÂ∑≤Ê∏ÖÈô§„ÄÇ',
                    toastPromptCopied: '‚ö° Â∑≤Â§çÂà∂ÊèêÁ§∫ËØç!',
                    toastFavoriteRenamed: '‚úèÔ∏è Â∑≤‰øÆÊîπÊî∂ËóèÂêçÁß∞„ÄÇ',
                    toastCapRenamed: '‚úèÔ∏è Â∑≤Êõ¥Êñ∞ËÉ∂ÂõäÂêçÁß∞„ÄÇ',
                    toastCapDeleted: 'üóëÔ∏è Â∑≤Âà†Èô§ËÉ∂Âõä„ÄÇ',
                    toastImportSuccess: 'üì• Êî∂ËóèÂ∑≤ÂØºÂÖ•„ÄÇ',
                    alertEmptyPrompt: 'ÂÜÖÂÆπ‰∏∫Á©∫„ÄÇ',
                    confirmReset: 'Á°ÆÂÆöÈáçÁΩÆÊâÄÊúâÊï∞ÊçÆÔºü',
                    confirmClearHistory: 'Ê∏ÖÈô§ÊâÄÊúâÂéÜÂè≤ËÆ∞ÂΩïÔºü',
                    newTagPrompt: 'Êñ∞ÁöÑÊ†áÁ≠æÂêçÁß∞Ôºö',
                    dockDeleteBadge: 'Âà†Èô§Ê®°Âºè',
                    settingsSave: '‰øùÂ≠òÊñá‰ª∂',
                    settingsOpen: 'ÊâìÂºÄÊñá‰ª∂',
                    settingsReset: 'ÈáçÁΩÆÂ∫îÁî®',
                    btnFavAria: 'Âä†ÂÖ•Êî∂Ëóè',
                    btnGenerateAria: 'ÁîüÊàê',
                    btnCopyAria: 'Â§çÂà∂ÊèêÁ§∫ËØç',
                    btnPrevAria: '‰∏ä‰∏ÄÊù°ÂéÜÂè≤',
                    btnNextAria: '‰∏ã‰∏ÄÊù°ÂéÜÂè≤',
                    btnAutoCopyAria: 'ÂàáÊç¢Ëá™Âä®Â§çÂà∂',
                    chipTrashHint: 'ÊãñÂà∞Ê≠§Â§ÑÂà†Èô§Á≠πÁ†Å',
                    settingsAria: 'ÊâìÂºÄËÆæÁΩÆ',
                    languageAria: 'ÂàáÊç¢ËØ≠Ë®Ä',
                    helpAria: 'Â∏ÆÂä©',
                    emptyPromptPreview: '(Á©∫ÊèêÁ§∫ËØç)',
                    chipLinkOn: 'Â∑≤ËøûÊé•',
                    chipLinkOff: 'ËøûÊé•',
                    chipUnlink: 'ÂèñÊ∂àËøûÊé•',
                    capEditTitle: 'ÈáçÂëΩÂêç',
                    capEditHint: '(ÁïôÁ©∫ÂàôÂà†Èô§)',
                    confirmLabel: 'Á°ÆÂÆö',
                    deleteLabel: 'Âà†Èô§',
                    cancelLabel: 'ÂèñÊ∂à',
                    importError: 'ÈîôËØØ: ',
                    historyTab: '‚è± ÂéÜÂè≤',
                    favoritesTab: '‚≠ê Êî∂Ëóè',
                    favoriteNamePrefix: 'Fav',
                    favEditTitle: 'Êî∂ËóèÂêçÁß∞',
                    favEditHint: '(ÁïôÁ©∫ÂàôÂà†Èô§)',
                    cancelLabel: 'ÂèñÊ∂à'
                }
            }
        };
                const BaseSchema = [
            {
                key: "subject", label: "Subject", options: []
            },
            {
                key: "number", label: "Number", options: []
            },
            {
                key: "year", label: "Year", options: []
            },
            {
                key: "operator", label: "Math", options: []
            },
            {
                key: "job", label: "Profession", options: []
            },
            {
                key: "hair", label: "Hair", options: []
            },
            {
                key: "eyes", label: "Eyes / Gaze", options: []
            },
            {
                key: "expression", label: "Expression", options: []
            },
            {
                key: "body", label: "Body", options: []
            },
            {
                key: "angle", label: "View / Angle", options: []
            },
            {
                key: "shot", label: "Shot Type", options: []
            },
            {
                key: "outfit", label: "Outfit", options: []
            },
            {
                key: "acc", label: "Accessory", options: []
            },
            {
                key: "action", label: "Action", options: []
            },
            {
                key: "bg", label: "Background", options: []
            },
            {
                key: "lighting", label: "Lighting", options: []
            },
            {
                key: "quality", label: "Quality", options: []
            },
            {
                key: "color", label: "Color", options: []
            },
            {
                key: "material", label: "Material", options: []
            },
            {
                key: "vibe", label: "Vibe", options: []
            },
            {
                key: "pattern", label: "Pattern", options: []
            }
        ];
        const ICON_COPY = `<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg" fill="none" style="width: 20px; height: 20px;"><g stroke-width="0"></g><g stroke-linecap="round" stroke-linejoin="round"></g><g> <path fill="currentColor" fill-rule="evenodd" d="M4 2a2 2 0 00-2 2v9a2 2 0 002 2h2v2a2 2 0 002 2h9a2 2 0 002-2V8a2 2 0 00-2-2h-2V4a2 2 0 00-2-2H4zm9 4V4H4v9h2V8a2 2 0 012-2h5zM8 8h9v9H8V8z"></path> </g></svg>`;

        class ReorderAnimator {
            static resolveContainer(container) {
                if (!container) return null;
                if (typeof container === 'string') return document.querySelector(container);
                return container;
            }
            static capture(container, selector, getKey) {
                const root = this.resolveContainer(container);
                if (!root) return null;
                const map = {};
                root.querySelectorAll(selector).forEach(el => {
                    const key = getKey ? getKey(el) : el?.dataset?.id;
                    if (!key) return;
                    map[key] = el.getBoundingClientRect();
                });
                return map;
            }
            static animate({ container, selector, prevPositions, getKey, transition = 'transform 0.25s ease', shouldLockWidth, onNewElement }) {
                if (!prevPositions) return;
                const root = this.resolveContainer(container);
                if (!root) return;
                const moving = [];
                root.querySelectorAll(selector).forEach(el => {
                    const key = getKey ? getKey(el) : el?.dataset?.id;
                    if (!key) return;
                    const prevRect = prevPositions[key];
                    if (!prevRect) {
                        if (typeof onNewElement === 'function') {
                            onNewElement(el);
                        }
                        return;
                    }
                    const rect = el.getBoundingClientRect();
                    const dx = prevRect.left - rect.left;
                    const dy = prevRect.top - rect.top;
                    const lockWidth = typeof shouldLockWidth === 'function'
                        ? shouldLockWidth(el, prevRect, rect)
                        : false;
                    if (lockWidth) {
                        el.style.width = `${prevRect.width}px`;
                    }
                    const moved = Math.abs(dx) > 1 || Math.abs(dy) > 1;
                    if (moved || lockWidth) {
                        el.style.transition = 'none';
                        el.style.transform = `translate(${dx}px, ${dy}px)`;
                        moving.push({ el, lockWidth, widthTarget: rect.width, moved });
                    } else if (lockWidth) {
                        requestAnimationFrame(() => {
                            el.style.width = `${rect.width}px`;
                            requestAnimationFrame(() => {
                                el.style.width = '';
                            });
                        });
                    }
                });
                if (!moving.length) return;
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        moving.forEach(({ el, lockWidth, widthTarget, moved }) => {
                            const transformTransition = transition;
                            const widthTransition = transformTransition.replace('transform', 'width');
                            const transitions = [];
                            if (moved) transitions.push(transformTransition);
                            if (lockWidth) transitions.push(widthTransition);
                            el.style.transition = transitions.join(', ');
                            el.style.transform = '';
                            if (lockWidth) {
                                requestAnimationFrame(() => {
                                    el.style.width = `${widthTarget}px`;
                                });
                            }
                            const done = { transform: !moved, width: !lockWidth };
                            const cleanup = (e) => {
                                if (e.propertyName === 'transform') {
                                    done.transform = true;
                                }
                                if (lockWidth && e.propertyName === 'width') {
                                    done.width = true;
                                    el.style.width = '';
                                }
                                if (done.transform && done.width) {
                                    el.style.transition = '';
                                    el.removeEventListener('transitionend', cleanup);
                                }
                            };
                            el.addEventListener('transitionend', cleanup);
                        });
                    });
                });
            }
        }

        class GapPreviewManager {
            constructor({ getItemElement, activeClass = 'gap-preview-active', shiftLeftClass = 'shift-left', shiftRightClass = 'shift-right', onGapActivate, onGapDeactivate } = {}) {
                this.getItemElement = getItemElement;
                this.activeClass = activeClass;
                this.shiftLeftClass = shiftLeftClass;
                this.shiftRightClass = shiftRightClass;
                this.onGapActivate = onGapActivate;
                this.onGapDeactivate = onGapDeactivate;
                this.currentIndex = null;
                this.activeGap = null;
                this.gapElements = {};
                this.reset();
            }
            reset() {
                this.clear();
                this.gapElements = {};
            }
            registerGap(index, el) {
                if (!el) return;
                if (!this.gapElements) this.gapElements = {};
                this.gapElements[index] = el;
            }
            set(index) {
                if (index === this.currentIndex) return;
                this.clear();
                this.currentIndex = index;
                const prev = this.getItemElement ? this.getItemElement(index - 1) : null;
                if (prev) prev.classList.add(this.shiftLeftClass);
                const next = this.getItemElement ? this.getItemElement(index) : null;
                if (next) next.classList.add(this.shiftRightClass);
                const gap = this.gapElements ? this.gapElements[index] : null;
                if (gap) {
                    gap.classList.add(this.activeClass);
                    if (typeof this.onGapActivate === 'function') {
                        this.onGapActivate(gap, index);
                    }
                }
                this.activeGap = gap || null;
            }
            clear(targetIndex = null) {
                if (this.currentIndex === null) return;
                if (targetIndex !== null && targetIndex !== this.currentIndex) return;
                const prev = this.getItemElement ? this.getItemElement(this.currentIndex - 1) : null;
                if (prev) prev.classList.remove(this.shiftLeftClass);
                const next = this.getItemElement ? this.getItemElement(this.currentIndex) : null;
                if (next) next.classList.remove(this.shiftRightClass);
                if (this.activeGap) {
                    this.activeGap.classList.remove(this.activeClass);
                    if (typeof this.onGapDeactivate === 'function') {
                        this.onGapDeactivate(this.activeGap, this.currentIndex);
                    }
                }
                this.activeGap = null;
                this.currentIndex = null;
            }
        }

        class PromptManager {
            constructor() {
                this.STORAGE_KEY = 'promania_v2_1_data';
                this.LOCALE_KEY = 'promania_locale';
                this.APP_VERSION = 'Promit 1.0';
                this.DATA_SCHEMA_VERSION = 1;
                this.MAX_HISTORY = 50;
                this.items = [];
                this.optionsData = {};
                this.customTypes = [];
                this.isDockDeleteMode = false;
                this.history = [];
                this.historyIndex = -1;
                this.favorites = [];
                this.dragSrcEl = null;
                this.dragType = null;
                this.activeDockTab = 'favorites';
                this.capLabels = {};
                this.rollHistory = [];
                this.favoriteUndoStack = [];
                this.capsuleOrder = [];
                this.capsuleDragIndex = null;
                this.capEditDialogEl = null;
                this.activeCapEditKey = null;
                this.activeCapEditEl = null;
                this.capEditOutsideHandler = null;
                this.capEditRepositionHandler = null;
                this.removedCapsules = [];
                this.activeFavoriteId = null;
                this.activeFavoriteName = '';
                this.skipFavoriteLabelClear = false;
                this.latestFavoriteId = null;
                this.favoriteDragId = null;
                this.activeFavoriteLabelCooldown = false;
                this.favEditDialogEl = null;
                this.activeFavEdit = null;
                this.favEditOutsideHandler = null;
                this.favEditRepositionHandler = null;
                this.locale = this.loadLocale();
                this.isLanguageMenuOpen = false;
                this.capsulesDirty = true;
                this.dockDirty = true;
                this.MAX_ROLL_HISTORY = 30;
                this.FAVORITE_UNDO_LIMIT = 10;
                this.isSettingsMenuOpen = false;
                this.AUTO_COPY_STORAGE_KEY = 'promania_v2_auto_copy';
                this.isAutoCopyEnabled = localStorage.getItem(this.AUTO_COPY_STORAGE_KEY) === '1';
                this.initTheme();
                this.chipGapPreview = new GapPreviewManager({
                    getItemElement: (idx) => this.getChipElementByIndex(idx),
                    onGapActivate: (gap, index) => {
                        if (index === 0) {
                            gap.classList.add('gap-preview-edge-left');
                        } else if (index === this.items.length) {
                            gap.classList.add('gap-preview-edge-right');
                        }
                    },
                    onGapDeactivate: (gap) => {
                        gap.classList.remove('gap-preview-edge-left', 'gap-preview-edge-right');
                    }
                });
                this.capsuleGapPreview = new GapPreviewManager({
                    getItemElement: (idx) => this.getCapsuleElementByIndex(idx),
                    onGapDeactivate: (gap) => {
                        gap.classList.remove('drag-over-gap');
                    }
                });
                this.favoriteGapPreview = new GapPreviewManager({
                    getItemElement: (idx) => this.getFavoriteChipElementByIndex(idx),
                    onGapActivate: (gap) => gap.classList.add('drag-over-gap'),
                    onGapDeactivate: (gap) => gap.classList.remove('drag-over-gap')
                });
                this.initOptionsData();
                if (!this.loadData()) {
                    this.initDefaultData();
                    this.syncCapsuleOrder();
                    this.pushHistory();
                } else {
                    this.sortAllOptions();
                }
                document.addEventListener('click', e => {
                    if (!e.target.closest('.chip') && !e.target.closest('.popover')) {
                        this.closePopover();
                    }
                    if (!e.target.closest('.settings-dropdown')) {
                        this.closeSettingsMenu();
                    }
                    if (!e.target.closest('.language-dropdown')) {
                        this.closeLanguageMenu();
                    }
                });
                this.initActiveFavoriteLabelHandler();
                this.bindStaticEventHandlers();
                document.addEventListener('keydown', e => {
                    const isInputTarget = e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable);
                    if ((e.ctrlKey || e.metaKey) && !isInputTarget) {
                        const key = e.key.toLowerCase();
                        if (key === 'z' && !e.shiftKey) {
                            e.preventDefault();
                            if (!this.undoFavoriteDeletion()) {
                                this.navHistory(-1);
                            }
                        } else if ((key === 'z' && e.shiftKey) || (key === 'y' && !e.shiftKey)) {
                            e.preventDefault();
                            this.navHistory(1);
                        }
                    }
                });
                this.render();
                this.updateAutoCopyUI();
                this.updateSettingsMenu();
                this.updateLanguageMenu();
                this.updateHelpContent();
                this.updateAriaLabels();
                this.updateDockTabLabels();
                this.updateThemeIcon(document.documentElement.getAttribute('data-theme') || 'dark');
            }
            loadLocale() {
                const saved = localStorage.getItem(this.LOCALE_KEY);
                if (saved && LOCALE_ORDER.includes(saved)) {
                    return saved;
                }
                return 'en';
            }
            t(key) {
                return (LOCALES[this.locale]?.strings?.[key]) || LOCALES.en.strings[key] || key;
            }
            initOptionsData() {
                BaseSchema.forEach(def => {
                    if (!this.optionsData[def.key]) {
                        this.optionsData[def.key] = def.options ? [...def.options] : [];
                    }
                    this.optionsData[def.key] = this.sortOptionsList(this.optionsData[def.key]);
                });
            }
            sortAllOptions() {
                Object.keys(this.optionsData).forEach(key => {
                    this.optionsData[key] = this.sortOptionsList(this.optionsData[key]);
                });
            }
            sortOptionsList(list = []) {
                if (!Array.isArray(list)) return [];
                const copy = [...list];
                copy.sort((a, b) => this.optionComparator(a, b));
                return copy;
            }
            optionComparator(a, b) {
                const normalize = val => (val ?? '').toString().trim();
                const aStr = normalize(a);
                const bStr = normalize(b);
                if (aStr === bStr) return 0;
                const aEmpty = aStr.length === 0;
                const bEmpty = bStr.length === 0;
                if (aEmpty || bEmpty) return aEmpty && bEmpty ? 0 : (aEmpty ? 1 : -1);
                const startsWithDigit = str => /^[0-9]/.test(str);
                const aDigit = startsWithDigit(aStr);
                const bDigit = startsWithDigit(bStr);
                if (aDigit && bDigit) {
                    return aStr.localeCompare(bStr, undefined, { numeric: true, sensitivity: 'base' });
                }
                if (aDigit !== bDigit) {
                    return aDigit ? -1 : 1;
                }
                return aStr.localeCompare(bStr, undefined, { sensitivity: 'base' });
            }
            getSortedOptions(type) {
                if (!this.optionsData[type]) {
                    this.optionsData[type] = [];
                }
                const sorted = this.sortOptionsList(this.optionsData[type]);
                this.optionsData[type] = sorted;
                return sorted;
            }
            loadData() {
                try {
                    const raw = localStorage.getItem(this.STORAGE_KEY);
                    if (!raw) return false;
                    const data = JSON.parse(raw);
                    const storedSchema = Number.isInteger(data.schemaVersion) ? data.schemaVersion : 0;
                    if (storedSchema > this.DATA_SCHEMA_VERSION) {
                        console.warn('Stored data uses newer schema.');
                        return false;
                    }
                    this.items = this.flattenItems(data.items || []);
                    this.optionsData = data.optionsData || this.optionsData;
                    this.customTypes = data.customTypes || [];
                    this.favorites = data.favorites || [];
                    this.capLabels = data.capLabels || {};
                    this.rollHistory = data.rollHistory || this.rollHistory;
                    this.capsuleOrder = data.capsuleOrder || [];
                    this.removedCapsules = data.removedCapsules || [];
                    this.activeFavoriteId = null;
                    this.activeFavoriteName = '';
                    this.skipFavoriteLabelClear = false;
                    this.ensureFavoriteNames();
                    this.sortAllOptions();
                    this.syncCapsuleOrder();
                    this.capsulesDirty = true;
                    return true;
                } catch (e) { console.error(e); return false; }
            }
            flattenItems(list) {
                let flat = [];
                list.forEach(item => {
                    if (item.type === 'group') {
                        const children = this.flattenItems(item.children);
                        flat = flat.concat(children);
                    } else {
                        if (item.linkNext === undefined) item.linkNext = false;
                        flat.push(item);
                    }
                });
                return flat;
            }
            saveData() {
                const data = {
                    schemaVersion: this.DATA_SCHEMA_VERSION,
                    version: this.APP_VERSION,
                    items: this.items,
                    optionsData: this.optionsData,
                    customTypes: this.customTypes,
                    favorites: this.favorites,
                    capLabels: this.capLabels,
                    rollHistory: this.rollHistory,
                    capsuleOrder: this.capsuleOrder,
                    removedCapsules: this.removedCapsules
                };
                localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));
            }
            initDefaultData() {
                this.items = [];
                this.history = [];
                this.historyIndex = -1;
                this.favorites = [];
                this.customTypes = [];
                this.capLabels = {};
                this.rollHistory = [];
                this.isDockDeleteMode = false;
                this.activeDockTab = 'favorites';
                this.capsulesDirty = true;
                this.dockDirty = true;
                this.optionsData = {};
                this.initOptionsData();
                this.capsuleOrder = this.getDefaultCapsuleOrder();
                this.removedCapsules = [];
                this.activeFavoriteId = null;
                this.activeFavoriteName = '';
                this.skipFavoriteLabelClear = false;
                this.latestFavoriteId = null;
                this.favoriteDragId = null;
                this.favoriteUndoStack = [];
            }
            getDefaultCapsuleOrder() {
                return BaseSchema.map(def => def.key);
            }
            getAllCapsuleKeys() {
                const baseKeys = BaseSchema
                    .map(def => def.key)
                    .filter(key => !this.removedCapsules.includes(key));
                const customKeys = this.customTypes.map(def => def.key);
                return baseKeys.concat(customKeys);
            }
            syncCapsuleOrder() {
                const allKeys = this.getAllCapsuleKeys();
                let order = Array.isArray(this.capsuleOrder) ? [...this.capsuleOrder] : [];
                order = order.filter((key, idx) => allKeys.includes(key) && order.indexOf(key) === idx);
                allKeys.forEach(key => {
                    if (!order.includes(key)) {
                        order.push(key);
                    }
                });
                this.capsuleOrder = order;
            }
            getCapsuleDefinition(key) {
                return BaseSchema.find(def => def.key === key) || this.customTypes.find(def => def.key === key) || null;
            }
            getCapsuleColor(key, fallbackIndex = 0) {
                const baseIdx = BaseSchema.findIndex(def => def.key === key);
                if (baseIdx !== -1) {
                    return this.getSoftColor(baseIdx);
                }
                const custom = this.customTypes.find(def => def.key === key);
                if (custom) {
                    if (!custom.capColor) {
                        custom.capColor = this.generatePastelColor();
                        this.saveData();
                    }
                    return custom.capColor;
                }
                return this.getSoftColor(fallbackIndex);
            }
            initActiveFavoriteLabelHandler() {
                const label = document.getElementById('activeFavoriteLabel');
                if (!label) return;
                const triggerEdit = () => {
                    if (!this.activeFavoriteId || label.classList.contains('is-editing') || this.activeFavoriteLabelCooldown) return;
                    this.beginActiveFavoriteInlineEdit();
                };
                label.addEventListener('click', () => {
                    triggerEdit();
                });
                label.addEventListener('keydown', (e) => {
                    if (label.classList.contains('is-editing') || this.activeFavoriteLabelCooldown) return;
                    if ((e.key === 'Enter' || e.key === ' ') && this.activeFavoriteId) {
                        e.preventDefault();
                        triggerEdit();
                    }
                });
                const editBtn = document.getElementById('activeFavEditBtn');
                if (editBtn) {
                    editBtn.addEventListener('click', (event) => {
                        event.preventDefault();
                        event.stopPropagation();
                        triggerEdit();
                    });
                }
            }
            bindStaticEventHandlers() {
                const helpBtn = document.querySelector('.help-btn');
                if (helpBtn) helpBtn.addEventListener('click', () => this.toggleHelp());
                const helpOverlay = document.getElementById('helpModal');
                if (helpOverlay) {
                    helpOverlay.addEventListener('click', () => this.toggleHelp());
                    const modal = helpOverlay.querySelector('.help-modal');
                    if (modal) modal.addEventListener('click', (e) => e.stopPropagation());
                    const closeBtn = helpOverlay.querySelector('.help-close');
                    if (closeBtn) closeBtn.addEventListener('click', (e) => { e.stopPropagation(); this.toggleHelp(); });
                }
                const langBtn = document.getElementById('languageBtn');
                if (langBtn) langBtn.addEventListener('click', (event) => this.toggleLanguageMenu(event));
                const settingsBtn = document.getElementById('settingsBtn');
                if (settingsBtn) settingsBtn.addEventListener('click', (event) => this.toggleSettingsMenu(event));
                const themeToggle = document.querySelector('.settings-row.theme-toggle');
                if (themeToggle) themeToggle.addEventListener('click', () => this.handleThemeToggle());
                document.querySelectorAll('#settingsMenu button[data-setting]').forEach(btn => {
                    btn.addEventListener('click', () => this.handleSettingsAction(btn.getAttribute('data-setting')));
                });
                const favBtn = document.querySelector('.btn-fav');
                if (favBtn) favBtn.addEventListener('click', () => this.action('fav'));
                const prevBtn = document.getElementById('btnPrev');
                if (prevBtn) prevBtn.addEventListener('click', () => this.navHistory(-1));
                const nextBtn = document.getElementById('btnNext');
                if (nextBtn) nextBtn.addEventListener('click', () => this.navHistory(1));
                const genBtn = document.querySelector('.btn-gen');
                if (genBtn) genBtn.addEventListener('click', () => this.action('generate'));
                const autoBtn = document.querySelector('.btn-auto-copy');
                if (autoBtn) autoBtn.addEventListener('click', () => this.toggleAutoCopy());
                const copyBtn = document.querySelector('.btn-copy');
                if (copyBtn) copyBtn.addEventListener('click', () => this.copyToClipboard());
                document.querySelectorAll('.dock-tab').forEach(tab => {
                    tab.addEventListener('click', () => this.switchDockTab(tab.dataset.tab));
                });
                const clearHistoryBtn = document.getElementById('dockClearHistory');
                if (clearHistoryBtn) clearHistoryBtn.addEventListener('click', () => this.clearRollHistory());
            }
            beginActiveFavoriteInlineEdit() {
                const label = document.getElementById('activeFavoriteLabel');
                if (!label || !this.activeFavoriteId) return;
                const currentName = this.activeFavoriteName || '';
                label.classList.add('is-editing');
                const safeValue = this.escapeAttribute(currentName);
                label.innerHTML = `<input type="text" class="active-fav-input" value="${safeValue}">`;
                const input = label.querySelector('input');
                if (!input) return;
                let finished = false;
                const cleanup = (shouldApply) => {
                    if (finished) return;
                    finished = true;
                    input.removeEventListener('blur', handleBlur);
                    input.removeEventListener('keydown', handleKey);
                    label.classList.remove('is-editing');
                    label.innerHTML = '';
                    label.blur();
                    this.activeFavoriteLabelCooldown = true;
                    setTimeout(() => { this.activeFavoriteLabelCooldown = false; }, 0);
                    if (shouldApply) {
                        this.commitActiveFavoriteInlineEdit(input.value);
                    } else {
                        this.updateActiveFavoriteLabel();
                    }
                };
                const handleBlur = () => cleanup(true);
                const handleKey = (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        cleanup(true);
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        cleanup(false);
                    }
                };
                input.addEventListener('blur', handleBlur);
                input.addEventListener('keydown', handleKey);
                requestAnimationFrame(() => {
                    input.focus();
                    input.select();
                });
            }
            commitActiveFavoriteInlineEdit(value) {
                if (!this.activeFavoriteId) {
                    this.updateActiveFavoriteLabel();
                    return;
                }
                const idx = this.favorites.findIndex(f => f.id === this.activeFavoriteId);
                if (idx === -1) {
                    this.updateActiveFavoriteLabel();
                    return;
                }
                const trimmed = (value || '').trim();
                if (!trimmed) {
                    this.deleteFavorite(idx);
                    return;
                }
                const current = this.favorites[idx].name || '';
                if (trimmed !== current) {
                    this.renameFavorite(idx, trimmed);
                } else {
                    this.activeFavoriteName = trimmed;
                    this.updateActiveFavoriteLabel();
                }
            }
            updateActiveFavoriteLabel() {
                const label = document.getElementById('activeFavoriteLabel');
                if (!label || label.classList.contains('is-editing')) return;
                if (this.activeFavoriteName) {
                    label.innerText = this.activeFavoriteName;
                    label.classList.add('is-visible');
                } else {
                    label.innerText = '';
                    label.classList.remove('is-visible');
                }
            }
            clearActiveFavoriteLabel() {
                this.activeFavoriteId = null;
                this.activeFavoriteName = '';
                this.updateActiveFavoriteLabel();
                this.skipFavoriteLabelClear = false;
            }
            ensureFavoriteNames() {
                if (!Array.isArray(this.favorites)) {
                    this.favorites = [];
                    return;
                }
                const used = new Set();
                let changed = false;
                this.favorites.forEach(fav => {
                    if (fav?.name) used.add(fav.name);
                });
                this.favorites.forEach(fav => {
                    if (!fav.name) {
                        fav.name = this.generateFavoriteName(used);
                        used.add(fav.name);
                        changed = true;
                    }
                    if (this.ensureFavoriteColor(fav)) {
                        changed = true;
                    }
                });
                if (changed) this.saveData();
            }
            generateFavoriteName(usedSet = null) {
                const used = usedSet || new Set(this.favorites.map(f => f.name));
                let idx = this.favorites.length + 1;
                let name;
                const prefix = this.t('favoriteNamePrefix') || 'Fav';
                do {
                    name = `${prefix} ${idx++}`;
                } while (used.has(name));
                return name;
            }
            ensureFavoriteColor(fav) {
                if (!fav) return false;
                let updated = false;
                if (!fav.color) {
                    const baseColor = this.generatePastelColor();
                    fav.color = baseColor;
                    fav.darkColor = this.createDarkVariant(baseColor);
                    updated = true;
                } else if (!fav.darkColor) {
                    fav.darkColor = this.createDarkVariant(fav.color);
                    updated = true;
                }
                return updated;
            }
            createItem(type, value = "", isCustom = false) {
                const def = BaseSchema.find(d => d.key === type);
                const baseColor = this.generatePastelColor();
                return {
                    id: (isCustom ? type : type + '_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5)),
                    type: type,
                    label: this.getTypeLabel(type),
                    value: value,
                    isRandom: false,
                    isCustom: isCustom,
                    linkNext: false,
                    color: baseColor,
                    darkColor: this.createDarkVariant(baseColor)
                };
            }
            addItem(type, value = "") {
                const item = this.createItem(type, value);
                this.items.push(item);
                this.pushHistory();
                this.render();
            }
            deleteItem(id) {
                const idx = this.items.findIndex(i => i.id === id);
                if (idx > -1) {
                    this.items.splice(idx, 1);
                    this.pushHistory();
                    this.render();
                }
            }
            pushHistory() {
                if (this.historyIndex < this.history.length - 1) {
                    this.history = this.history.slice(0, this.historyIndex + 1);
                }
                const snapshot = JSON.parse(JSON.stringify(this.items));
                this.history.push(snapshot);
                if (this.history.length > this.MAX_HISTORY) {
                    this.history.shift();
                }
                this.historyIndex = Math.max(0, this.history.length - 1);
                this.saveData();
                if (this.skipFavoriteLabelClear) {
                    this.skipFavoriteLabelClear = false;
                } else {
                    this.clearActiveFavoriteLabel();
                }
            }
            navHistory(dir) {
                const newIndex = this.historyIndex + dir;
                if (newIndex >= 0 && newIndex < this.history.length) {
                    this.historyIndex = newIndex;
                    this.items = JSON.parse(JSON.stringify(this.history[this.historyIndex]));
                    this.saveData();
                    this.render();
                }
            }
            updateNavArrows() {
                const prev = document.getElementById('btnPrev');
                const next = document.getElementById('btnNext');
                const hasPrev = this.historyIndex > 0;
                const hasNext = this.historyIndex < this.history.length - 1;
                prev.classList.toggle('disabled', !hasPrev);
                next.classList.toggle('disabled', !hasNext);
            }
            render() {
                if (this.capsulesDirty) {
                    this.renderCapsules();
                }
                this.renderChips();
                this.updateActiveFavoriteLabel();
                this.updateNavArrows();
                if (this.dockDirty) {
                    this.renderDockList();
                }
                this.updateFavButtonState();
                this.setupChipTrashZone();
                this.updateAriaLabels();
            }
            renderCapsules() {
                const container = document.getElementById('capsuleContainer');
                if (!container) {
                    this.capsulesDirty = false;
                    return;
                }
                this.closeCapEditDialog();
                this.syncCapsuleOrder();
                const prevPositions = this.captureCapsulePositions();
                this.capsulesDirty = false;
                this.clearCapsuleGapPreview();
                if (this.capsuleGapPreview) this.capsuleGapPreview.reset();
                container.innerHTML = '';

                const orderedKeys = (this.capsuleOrder && this.capsuleOrder.length)
                    ? [...this.capsuleOrder]
                    : this.getAllCapsuleKeys();

                const appendGap = (index, position) => {
                    const gap = this.createCapsuleGap(index, position);
                    container.appendChild(gap);
                };

                appendGap(0, 'head');

                orderedKeys.forEach((key, idx) => {
                    const def = this.getCapsuleDefinition(key);
                    if (!def) return;
                    const cap = this.el('div', 'cap', this.getTypeLabel(def.key));
                    cap.dataset.capKey = key;
                    cap.dataset.capIndex = idx;
                    const baseColor = this.getCapsuleColor(def.key, idx);
                    cap.style.backgroundColor = this.isDarkTheme() ? this.createDarkVariant(baseColor) : baseColor;
                    cap.onclick = () => {
                        if (cap.classList.contains('cap-editing')) return;
                        if (cap.isLongPress) {
                            cap.isLongPress = false;
                            return;
                        }
                        this.closePopover();
                        this.addItem(def.key);
                    };
                    cap.draggable = true;
                    cap.ondragstart = (e) => {
                        this.closePopover();
                        this.dragType = 'capsule';
                        this.dragCapsuleData = { source: 'capsule', type: def.key };
                        this.capsuleDragIndex = idx;
                        e.dataTransfer.setData('text/plain', JSON.stringify(this.dragCapsuleData));
                        e.dataTransfer.effectAllowed = 'copyMove';
                        document.body.classList.add('is-dragging');
                        cap.classList.add('dragging');
                    };
                    cap.ondragend = () => {
                        document.body.classList.remove('is-dragging');
                        cap.classList.remove('dragging');
                        this.dragCapsuleData = null;
                        this.dragType = null;
                        this.capsuleDragIndex = null;
                        this.clearCapsuleGapPreview();
                        this.clearGapPreview();
                        document.querySelectorAll('.drag-over-gap').forEach(el => el.classList.remove('drag-over-gap'));
                    };
                    this.addLongPress(cap, () => this.openCapEditDialog(def.key, cap), 600);
                    container.appendChild(cap);
                    const isLast = idx === orderedKeys.length - 1;
                    appendGap(idx + 1, isLast ? 'tail' : undefined);
                });

                const addBtn = this.el('div', 'cap cap-add', '+');
                addBtn.onclick = () => this.addCustomType();
                container.appendChild(addBtn);

                this.animateCapsuleReflow(prevPositions);
            }
            createCapsuleGap(index, position) {
                const gap = this.el('div', 'cap-drop-zone');
                if (position) gap.classList.add(position);
                gap.dataset.index = index;
                gap.ondragover = (e) => {
                    if (this.dragType !== 'capsule') return;
                    e.preventDefault();
                    e.stopPropagation();
                    gap.classList.add('drag-over-gap');
                    this.setCapsuleGapPreview(index);
                };
                gap.ondragleave = () => {
                    gap.classList.remove('drag-over-gap');
                    this.clearCapsuleGapPreview(index);
                };
                gap.ondrop = (e) => {
                    if (this.dragType !== 'capsule') return;
                    e.preventDefault();
                    e.stopPropagation();
                    gap.classList.remove('drag-over-gap');
                    this.clearCapsuleGapPreview();
                    this.handleCapsuleReorder(index);
                };
                if (this.capsuleGapPreview) this.capsuleGapPreview.registerGap(index, gap);
                return gap;
            }
            getCapsuleElementByIndex(idx) {
                if (idx < 0) return null;
                return document.querySelector(`#capsuleContainer .cap[data-cap-index="${idx}"]`);
            }
            setCapsuleGapPreview(index) {
                if (this.capsuleGapPreview) this.capsuleGapPreview.set(index);
            }
            clearCapsuleGapPreview(targetIndex = null) {
                if (this.capsuleGapPreview) this.capsuleGapPreview.clear(targetIndex);
            }
            handleCapsuleReorder(insertIndex) {
                if (this.capsuleDragIndex === null) return;
                const order = Array.isArray(this.capsuleOrder) ? [...this.capsuleOrder] : [];
                if (!order.length) return;
                const [moved] = order.splice(this.capsuleDragIndex, 1);
                if (!moved) return;
                let targetIndex = insertIndex;
                if (this.capsuleDragIndex < insertIndex) {
                    targetIndex = Math.max(0, insertIndex - 1);
                }
                targetIndex = Math.min(Math.max(targetIndex, 0), order.length);
                order.splice(targetIndex, 0, moved);
                this.capsuleOrder = order;
                this.capsuleDragIndex = null;
                this.capsulesDirty = true;
                this.saveData();
                this.render();
            }
            captureCapsulePositions() {
                return ReorderAnimator.capture('#capsuleContainer', '.cap', cap => cap.dataset.capKey);
            }
            animateCapsuleReflow(prevPositions) {
                ReorderAnimator.animate({
                    container: '#capsuleContainer',
                    selector: '.cap',
                    prevPositions,
                    getKey: cap => cap.dataset.capKey,
                    transition: 'transform 0.28s cubic-bezier(0.22, 0.61, 0.36, 1)'
                });
            }

            addCustomType() {
                const name = prompt(this.t('newTagPrompt'));
                if (name) {
                    const key = "custom_" + Date.now();
                    const capColor = this.generatePastelColor();
                    this.customTypes.push({ key, label: name, capColor });
                    this.optionsData[key] = [];
                    this.capsuleOrder.push(key);
                    this.syncCapsuleOrder();
                    this.capsulesDirty = true;
                    this.addItem(key);
                }
            }

            renderChips() {
                const container = document.getElementById('chipContainer');
                this.clearGapPreview();
                const prevPositions = this.captureChipPositions();
                container.innerHTML = '';
                if (this.chipGapPreview) this.chipGapPreview.reset();
                this.teardownEmptyChipDrop(container);

                if (this.items.length === 0) {
                    container.innerHTML = `<div class="empty-state">${this.t('chipEmptyState')}</div>`;
                    this.setupEmptyChipDrop(container);
                    return;
                }

                container.classList.remove('is-empty-drop', 'drag-over');

                const head = this.el('div', 'chip-drop-zone head');
                this.setupBridgeDrop(head, 0);
                container.appendChild(head);

                this.items.forEach((item, idx) => {
                    const chip = this.createChipElement(item, idx);

                    if (item.linkNext && idx < this.items.length - 1) {
                        chip.classList.add('linked-left');
                    }
                    if (idx > 0 && this.items[idx - 1].linkNext) {
                        chip.classList.add('linked-right');
                    }
                    container.appendChild(chip);

                    if (idx < this.items.length - 1) {
                        const bridge = this.el('div', 'chip-bridge');
                        if (item.linkNext) {
                            bridge.classList.add('active');
                            bridge.title = this.t('chipLinkOn');
                        } else {
                            bridge.title = this.t('chipLinkOff');
                        }
                        const toggleLink = (e) => {
                            e.stopPropagation();
                            this.closePopover();
                            item.linkNext = !item.linkNext;
                            this.pushHistory();
                            this.render();
                        };

                        bridge.onclick = toggleLink;

                        if (item.linkNext) {
                            const toggleHotspot = this.el('div', 'chip-link-toggle');
                            toggleHotspot.title = this.t('chipUnlink');
                            toggleHotspot.onclick = toggleLink;
                            bridge.appendChild(toggleHotspot);
                        }

                        this.setupBridgeDrop(bridge, idx + 1);

                        container.appendChild(bridge);
                    }
                });
                const tail = this.el('div', 'chip-drop-zone tail');
                this.setupBridgeDrop(tail, this.items.length);
                container.appendChild(tail);

                this.animateChipReflow(prevPositions);
            }

            setupEmptyChipDrop(container) {
                if (!container) return;
                container.classList.add('is-empty-drop');
                const handleOver = (e) => {
                    const data = this.getDragPayload(e);
                    if (!data || (data.source !== 'capsule' && data.source !== 'favorite' && data.source !== 'chip')) return;
                    e.preventDefault();
                    container.classList.add('drag-over');
                };
                const handleLeave = (e) => {
                    if (e) e.stopPropagation();
                    container.classList.remove('drag-over');
                };
                const handleDrop = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    container.classList.remove('drag-over');
                    this.clearGapPreview();
                    this.handleDrop(e, 0);
                };
                container.ondragover = handleOver;
                container.ondragleave = handleLeave;
                container.ondrop = handleDrop;
            }

            teardownEmptyChipDrop(container) {
                if (!container) return;
                container.classList.remove('is-empty-drop', 'drag-over');
                container.ondragover = null;
                container.ondragleave = null;
                container.ondrop = null;
            }

            setupBridgeDrop(el, insertIndex) {
                el.ondragover = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    el.classList.add('drag-over-gap');
                    const copySource = this.dragType === 'capsule' || this.dragType === 'favorite';
                    if (e.dataTransfer) {
                        e.dataTransfer.dropEffect = copySource ? 'copy' : 'move';
                    }
                    if (this.dragType) {
                        this.setGapPreview(insertIndex);
                    }
                };

                el.ondragleave = () => {
                    el.classList.remove('drag-over-gap');
                    this.clearGapPreview(insertIndex);
                };

                el.ondrop = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    el.classList.remove('drag-over-gap');
                    this.clearGapPreview();
                    this.handleDrop(e, insertIndex);
                };

                if (this.chipGapPreview) this.chipGapPreview.registerGap(insertIndex, el);
            }

            getChipElementByIndex(idx) {
                if (idx < 0) return null;
                return document.querySelector(`#chipContainer .chip[data-index="${idx}"]`);
            }

            getFavoriteChipElementByIndex(idx) {
                if (idx < 0) return null;
                return document.querySelector(`#dockList .fav-name-chip[data-fav-index="${idx}"]`);
            }

            setGapPreview(insertIndex) {
                if (this.chipGapPreview) this.chipGapPreview.set(insertIndex);
            }

            clearGapPreview(targetIndex = null) {
                if (this.chipGapPreview) this.chipGapPreview.clear(targetIndex);
            }

            captureChipPositions() {
                return ReorderAnimator.capture('#chipContainer', '.chip', chip => chip.dataset.id);
            }

            animateChipReflow(prevPositions) {
                ReorderAnimator.animate({
                    container: '#chipContainer',
                    selector: '.chip',
                    prevPositions,
                    getKey: chip => chip.dataset.id,
                    transition: 'transform 0.28s cubic-bezier(0.22, 0.61, 0.36, 1)',
                    shouldLockWidth: (chip, prevRect, rect) => {
                        const isLinked = chip.classList.contains('linked-left') || chip.classList.contains('linked-right');
                        return isLinked && (prevRect.width - rect.width) > 0.5;
                    },
                    onNewElement: (chip) => {
                        chip.classList.add('pop-in');
                        chip.addEventListener('animationend', () => chip.classList.remove('pop-in'), { once: true });
                    }
                });
            }

            captureDockPositions(listEl = null) {
                const container = listEl || '#dockList';
                return ReorderAnimator.capture(container, '.fav-item, .fav-name-chip, .history-item', item => item.dataset.dockId);
            }

            animateDockReflow(prevPositions) {
                ReorderAnimator.animate({
                    container: '#dockList',
                    selector: '.fav-item, .fav-name-chip, .history-item',
                    prevPositions,
                    getKey: item => item.dataset.dockId,
                    transition: 'transform 0.25s cubic-bezier(0.22, 0.61, 0.36, 1)'
                });
            }

            createChipElement(item, idx) {
                const chip = this.el('div', 'chip');
                chip.dataset.id = item.id;
                chip.dataset.index = idx;
                chip.draggable = true;

                this.ensureItemColorPair(item);
                const hasValue = !!item.value;
                chip.classList.toggle('is-empty', !hasValue);

                if (hasValue) {
                    chip.style.backgroundColor = this.getItemColor(item);
                } else {
                    chip.style.backgroundColor = "transparent";
                    chip.style.border = "1px dashed var(--border)";
                    chip.style.color = "var(--text-sub)";
                }
                if (hasValue) {
                    const iconChar = item.isRandom ? "üé≤" : "üîí";
                    const iconSpan = this.el('span', 'chip-icon', iconChar);
                    iconSpan.onclick = (e) => {
                        e.stopPropagation();
                        item.isRandom = !item.isRandom;
                        this.pushHistory();
                        this.render();
                    };
                    chip.appendChild(iconSpan);
                }
                chip.appendChild(document.createTextNode(item.value || `+ ${item.label}`));
                chip.onclick = () => this.handleChipClick(item, chip);
                this.setupDragEvents(chip, item, idx);
                return chip;
            }

            handleChipClick(item, chipEl) {
                if (!item || !chipEl) return;
                if (chipEl.isLongPress) {
                    chipEl.isLongPress = false;
                    return;
                }
                if (chipEl.isDragging) {
                    chipEl.isDragging = false;
                    return;
                }
                const pop = document.getElementById('popover');
                const isSameActive = pop && pop.classList.contains('active') && this.activePopoverKey === item.id;
                if (isSameActive) {
                    this.closePopover();
                    return;
                }
                this.openPopover(item, chipEl);
            }

            setupDragEvents(el, item, idx) {
                el.ondragstart = (e) => {
                    e.stopPropagation();
                    this.closePopover();
                    this.dragSrcEl = { item, idx };
                    this.dragType = 'chip';
                    el.classList.add('dragging');
                    el.isDragging = true;
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', JSON.stringify({ source: 'chip', id: item.id }));
                    document.body.classList.add('is-dragging');
                };

                el.ondragend = () => {
                    el.classList.remove('dragging');
                    el.isDragging = false;
                    this.dragSrcEl = null;
                    this.dragType = null;
                    this.clearGapPreview();
                    document.body.classList.remove('is-dragging');
                    document.querySelectorAll('.drag-over-gap').forEach(e => {
                        e.classList.remove('drag-over-gap');
                    });
                };
            }

            prepareGapForInsertion(targetIdx) {
                if (targetIdx > 0 && this.items[targetIdx - 1]?.linkNext) {
                    this.items[targetIdx - 1].linkNext = false;
                }
            }

            handleDrop(e, targetIdx) {
                const data = this.getDragPayload(e);
                if (!data) {
                    return;
                }

                if (data.source === 'capsule') {
                    const newItem = this.createItem(data.type);
                    if (targetIdx > 0 && this.items[targetIdx - 1]?.linkNext) {
                        newItem.linkNext = true;
                    }

                    this.items.splice(targetIdx, 0, newItem);
                    this.pushHistory();
                    this.render();
                    return;
                }

                if (data.source === 'favorite') {
                    const favId = Number(data.id);
                    if (!favId) return;
                    const fav = this.favorites.find(f => f.id === favId);
                    if (!fav) return;
                    const cloneItems = Array.isArray(fav.items) ? fav.items.map(item => {
                        const cloned = JSON.parse(JSON.stringify(item));
                        cloned.id = `${cloned.type}_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
                        this.ensureItemColorPair(cloned);
                        return cloned;
                    }) : [];
                    if (!cloneItems.length) return;
                    this.prepareGapForInsertion(targetIdx);
                    this.items.splice(targetIdx, 0, ...cloneItems);
                    this.pushHistory();
                    this.render();
                    this.showToast(this.t('toastFavoriteApplied'));
                    return;
                }

                if (this.dragSrcEl) {
                    const srcIdx = this.dragSrcEl.idx;
                    if (srcIdx === targetIdx || srcIdx === targetIdx - 1) return;
                    const getChainRange = (idx) => {
                        let start = idx;
                        let end = idx;
                        while (start > 0 && this.items[start - 1]?.linkNext) {
                            start--;
                        }
                        while (end < this.items.length - 1 && this.items[end]?.linkNext) {
                            end++;
                        }
                        return { start, end };
                    };

                    const srcChain = getChainRange(srcIdx);
                    const isInSameChain = targetIdx >= srcChain.start && targetIdx <= srcChain.end + 1;

                    const originalLinkNext = this.dragSrcEl.item.linkNext;
                    const prevItemLinkedToSrc = srcIdx > 0 && this.items[srcIdx - 1]?.linkNext;
                    const [movedItem] = this.items.splice(srcIdx, 1);
                    if (srcIdx > 0 && prevItemLinkedToSrc && srcIdx - 1 < this.items.length) {
                        this.items[srcIdx - 1].linkNext = originalLinkNext;
                    }
                    let finalIdx = targetIdx;
                    if (srcIdx < targetIdx) {
                        finalIdx--;
                    }
                    if (isInSameChain) {
                        const actualPrevItem = finalIdx > 0 ? this.items[finalIdx - 1] : null;
                        const actualNextItem = finalIdx < this.items.length ? this.items[finalIdx] : null;
                        if (actualPrevItem?.linkNext || (actualNextItem && prevItemLinkedToSrc)) {
                            movedItem.linkNext = true;
                        } else {
                            movedItem.linkNext = actualPrevItem?.linkNext === true;
                        }
                        if (finalIdx === this.items.length) {
                            movedItem.linkNext = false;
                        }
                    } else {
                        const actualPrevItem = finalIdx > 0 ? this.items[finalIdx - 1] : null;
                        movedItem.linkNext = actualPrevItem?.linkNext === true;
                    }

                    this.items.splice(finalIdx, 0, movedItem);
                    this.pushHistory();
                    this.render();
                }
            }

            getDragPayload(event) {
                let data = null;
                if (event && event.dataTransfer) {
                    try {
                        const raw = event.dataTransfer.getData('text/plain');
                        if (raw) data = JSON.parse(raw);
                    } catch (err) { }
                }
                if (!data && this.dragCapsuleData) {
                    data = this.dragCapsuleData;
                }
                if (!data && this.dragSrcEl) {
                    data = { source: 'chip', id: this.dragSrcEl.item.id };
                }
                return data;
            }

            setupChipTrashZone() {
                const trash = document.getElementById('chipTrashArea');
                if (!trash) return;
                const hint = this.t('chipTrashHint');
                trash.setAttribute('aria-label', hint);
                trash.setAttribute('title', hint);
                trash.ondragover = (e) => {
                    e.stopPropagation();
                    const data = this.getDragPayload(e);
                    if (!data || data.source !== 'chip') return;
                    e.preventDefault();
                    trash.classList.add('drag-over');
                    if (e.dataTransfer) e.dataTransfer.dropEffect = 'move';
                };
                trash.ondragleave = (e) => {
                    if (e) e.stopPropagation();
                    trash.classList.remove('drag-over');
                };
                trash.ondrop = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const data = this.getDragPayload(e);
                    trash.classList.remove('drag-over');
                    if (!data || data.source !== 'chip') return;
                    this.clearGapPreview();
                    this.deleteItem(data.id);
                };
            }

            buildPromptFromItems(list) {
                if (!Array.isArray(list)) return "";
                let prompt = "";
                list.forEach((item, i) => {
                    if (!item.value) return;
                    prompt += item.value;
                    if (i < list.length - 1) {
                        if (item.linkNext) {
                            prompt += " ";
                        } else {
                            prompt += ", ";
                        }
                    }
                });
                return prompt;
            }
            generatePrompt() {
                return this.buildPromptFromItems(this.items);
            }
            generateValues(isLucky = false) {
                let changed = false;
                this.items.forEach(item => {
                    if (item.value !== "" && !item.isRandom) return;
                    const opts = this.optionsData[item.type];
                    if (!opts || opts.length === 0) return;
                    if (isLucky || item.isRandom) {
                        item.value = opts[Math.floor(Math.random() * opts.length)];
                        item.isRandom = true;
                        changed = true;
                    }
                });
                if (changed) { this.pushHistory(); this.render(); }
            }
            findItemById(id) {
                return this.items.find(i => i.id === id);
            }
            el(tag, className, text) { const d = document.createElement(tag); if (className) d.className = className; if (text) d.innerText = text; return d; }
            generatePastelColor() {
                const hue = Math.floor(Math.random() * 360);
                const saturation = 35 + Math.floor(Math.random() * 25);
                const lightness = 70 + Math.floor(Math.random() * 15);
                return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            }

            getSoftColor(index) {
                const hex = Palette[index % Palette.length];
                const hsl = this.hexToHsl(hex);
                if (!hsl) return hex;
                return this.hslToString({ h: hsl.h, s: this.clamp(hsl.s, 30, 70), l: 72 });
            }

            isDarkTheme() {
                return (document.documentElement.getAttribute('data-theme') || 'dark') === 'dark';
            }

            ensureItemColorPair(item) {
                if (!item) return;
                if (!item.color) item.color = this.generatePastelColor();
                item.darkColor = this.createDarkVariant(item.color);
            }

            getItemColor(item) {
                this.ensureItemColorPair(item);
                return this.isDarkTheme() ? (item.darkColor || item.color) : item.color;
            }

            createDarkVariant(color) {
                const hsl = this.parseColorToHsl(color);
                if (!hsl) return color;
                return this.hslToString({
                    h: hsl.h,
                    s: this.clamp(hsl.s - 25, 5, 70),
                    l: this.clamp(hsl.l - 40, 10, 40)
                });
            }

            parseColorToHsl(color) {
                if (!color) return null;
                const trimmed = color.trim();
                if (trimmed.startsWith('hsl')) {
                    return this.parseHslString(trimmed);
                }
                if (trimmed.startsWith('#')) {
                    return this.hexToHsl(trimmed);
                }
                return null;
            }

            parseHslString(str) {
                const match = str.match(/hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%/i);
                if (!match) return null;
                return {
                    h: parseFloat(match[1]),
                    s: parseFloat(match[2]),
                    l: parseFloat(match[3])
                };
            }
            escapeSelector(value) {
                if (typeof value !== 'string') return '';
                if (window.CSS && typeof CSS.escape === 'function') {
                    return CSS.escape(value);
                }
                const string = String(value);
                const length = string.length;
                if (!length) return '';
                let result = '';
                let index = -1;
                const firstCodeUnit = string.charCodeAt(0);
                while (++index < length) {
                    const codeUnit = string.charCodeAt(index);
                    if (codeUnit === 0x0000) {
                        result += '\uFFFD';
                        continue;
                    }
                    if ((codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit === 0x007F || (index === 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) || (index === 1 && codeUnit >= 0x0030 && codeUnit <= 0x0039 && firstCodeUnit === 0x002D)) {
                        result += '\\' + codeUnit.toString(16) + ' ';
                        continue;
                    }
                    if (codeUnit >= 0x0080 || codeUnit === 0x002D || codeUnit === 0x005F || (codeUnit >= 0x0030 && codeUnit <= 0x0039) || (codeUnit >= 0x0041 && codeUnit <= 0x005A) || (codeUnit >= 0x0061 && codeUnit <= 0x007A)) {
                        result += string.charAt(index);
                        continue;
                    }
                    result += '\\' + string.charAt(index);
                }
                return result;
            }
            escapeAttribute(value) {
                if (value === null || value === undefined) return '';
                return String(value)
                    .replace(/&/g, '&amp;')
                    .replace(/"/g, '&quot;')
                    .replace(/</g, '&lt;');
            }
            escapeHtml(value) {
                if (value === null || value === undefined) return '';
                return String(value)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;');
            }
            sanitizeColorValue(value) {
                if (typeof value !== 'string') return '';
                const trimmed = value.trim();
                return /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/.test(trimmed) ? trimmed : '';
            }
            isPlainObject(value) {
                return Object.prototype.toString.call(value) === '[object Object]';
            }
            cloneData(value, fallback) {
                try {
                    return JSON.parse(JSON.stringify(value));
                } catch (err) {
                    return fallback;
                }
            }
            validateSchemaVersion(payload) {
                const version = Number(payload?.schemaVersion);
                return Number.isInteger(version) && version === this.DATA_SCHEMA_VERSION;
            }
            sanitizeFullStatePayload(payload) {
                if (!this.isPlainObject(payload)) return null;
                if (!this.validateSchemaVersion(payload)) return null;
                if (!Array.isArray(payload.items) || !this.isPlainObject(payload.optionsData)) return null;
                const safe = {
                    schemaVersion: this.DATA_SCHEMA_VERSION,
                    version: typeof payload.version === 'string' ? payload.version : this.APP_VERSION,
                    items: this.cloneData(payload.items, []),
                    optionsData: this.cloneData(payload.optionsData, {}),
                    customTypes: this.cloneData(payload.customTypes || [], []),
                    favorites: this.cloneData(payload.favorites || [], []),
                    capLabels: this.cloneData(payload.capLabels || {}, {}),
                    rollHistory: this.cloneData(payload.rollHistory || [], []),
                    capsuleOrder: this.cloneData(payload.capsuleOrder || [], []),
                    removedCapsules: this.cloneData(payload.removedCapsules || [], [])
                };
                return safe;
            }
            sanitizePartialImport(payload) {
                if (!this.isPlainObject(payload)) return null;
                if (!this.validateSchemaVersion(payload)) return null;
                return {
                    favorites: this.cloneData(payload.favorites || [], []),
                    customTypes: this.cloneData(payload.customTypes || [], []),
                    capLabels: this.cloneData(payload.capLabels || {}, {})
                };
            }

            hexToHsl(hex) {
                let clean = hex.replace('#', '');
                if (clean.length === 3) {
                    clean = clean.split('').map(ch => ch + ch).join('');
                }
                if (clean.length !== 6) return null;
                const r = parseInt(clean.slice(0, 2), 16);
                const g = parseInt(clean.slice(2, 4), 16);
                const b = parseInt(clean.slice(4, 6), 16);
                return this.rgbToHslValues(r, g, b);
            }

            rgbToHslValues(r, g, b) {
                r /= 255; g /= 255; b /= 255;
                const max = Math.max(r, g, b), min = Math.min(r, g, b);
                let h = 0, s = 0;
                const l = (max + min) / 2;
                if (max !== min) {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }
                return {
                    h: Math.round(h * 360),
                    s: Math.round(s * 100),
                    l: Math.round(l * 100)
                };
            }

            hslToString({ h, s, l }) {
                return `hsl(${Math.round(h)}, ${Math.round(s)}%, ${Math.round(l)}%)`;
            }

            clamp(value, min, max) {
                return Math.min(max, Math.max(min, value));
            }

            getTypeLabel(type) {
                if (this.capLabels[type]) return this.capLabels[type];
                const base = BaseSchema.find(d => d.key === type);
                if (base) return base.label;
                const custom = this.customTypes.find(c => c.key === type);
                if (custom) return custom.label;
                return type;
            }

            addLongPress(el, action, duration) {
                let t;
                const start = () => {
                    el.isLongPress = false;
                    t = setTimeout(() => {
                        el.isLongPress = true;
                        if (navigator.vibrate) navigator.vibrate(50);
                        action();
                    }, duration);
                };
                const end = () => {
                    clearTimeout(t);
                    if (el.isLongPress) {
                        setTimeout(() => { el.isLongPress = false; }, 50);
                    }
                };
                el.onmousedown = start; el.ontouchstart = start; el.onmouseup = end; el.ontouchend = end; el.onmouseleave = end;
                el.addEventListener('dragstart', end);
            }
            showToast(msg) {
                const toast = document.getElementById('toast');
                toast.innerText = msg;
                toast.classList.add('show');
                setTimeout(() => toast.classList.remove('show'), 2000);
            }
            initTheme() {
                const saved = localStorage.getItem('promania-theme') || 'dark';
                document.documentElement.setAttribute('data-theme', saved);
                this.updateThemeIcon(saved);
            }
            toggleTheme() {
                const current = document.documentElement.getAttribute('data-theme');
                const next = current === 'dark' ? 'light' : 'dark';
                document.documentElement.setAttribute('data-theme', next);
                localStorage.setItem('promania-theme', next);
                this.updateThemeIcon(next);
                this.capsulesDirty = true;
                this.dockDirty = true;
                this.render();
            }
            updateThemeIcon(theme) {
                const icon = document.getElementById('themeToggleIcon');
                if (icon) {
                    icon.innerText = theme === 'dark' ? 'üåô' : '‚òÄÔ∏è';
                }
            }
            toggleHelp() {
                const modal = document.getElementById('helpModal');
                if (modal.classList.contains('active')) { modal.classList.remove('active'); setTimeout(() => modal.style.display = 'none', 300); }
                else { modal.style.display = 'flex'; void modal.offsetWidth; modal.classList.add('active'); }
            }
            toggleSettingsMenu(event) {
                event?.stopPropagation();
                this.isSettingsMenuOpen = !this.isSettingsMenuOpen;
                this.updateSettingsMenu();
            }
            closeSettingsMenu() {
                if (!this.isSettingsMenuOpen) return;
                this.isSettingsMenuOpen = false;
                this.updateSettingsMenu();
            }
            updateSettingsMenu() {
                const menu = document.getElementById('settingsMenu');
                const btn = document.getElementById('settingsBtn');
                if (!menu || !btn) return;
                menu.classList.toggle('open', this.isSettingsMenuOpen);
                btn.setAttribute('aria-expanded', this.isSettingsMenuOpen ? 'true' : 'false');
                btn.setAttribute('aria-label', this.t('settingsAria'));
                menu.querySelectorAll('button[data-setting]').forEach(el => {
                    const key = el.getAttribute('data-setting');
                    const label = this.t(key === 'export' ? 'settingsSave' : key === 'import' ? 'settingsOpen' : 'settingsReset');
                    const span = el.querySelector('.settings-label');
                    if (span) span.innerText = label;
                });
            }
            handleSettingsAction(action) {
                this.closeSettingsMenu();
                switch (action) {
                    case 'theme':
                        this.toggleTheme();
                        break;
                    case 'export':
                        this.action('export');
                        break;
                    case 'import':
                        this.action('import');
                        break;
                    case 'reset':
                        this.action('reset');
                        break;
                }
            }
            handleThemeToggle() {
                this.toggleTheme();
            }
            toggleLanguageMenu(event) {
                event?.stopPropagation();
                this.isLanguageMenuOpen = !this.isLanguageMenuOpen;
                this.updateLanguageMenu();
            }
            closeLanguageMenu() {
                if (!this.isLanguageMenuOpen) return;
                this.isLanguageMenuOpen = false;
                this.updateLanguageMenu();
            }
            getLocaleMeta(code) {
                return LOCALES[code] || LOCALES.en;
            }
            updateLanguageMenu() {
                const menu = document.getElementById('languageMenu');
                const btn = document.getElementById('languageBtn');
                if (!menu || !btn) return;
                menu.classList.toggle('open', !!this.isLanguageMenuOpen);
                btn.setAttribute('aria-expanded', this.isLanguageMenuOpen ? 'true' : 'false');
                btn.innerText = 'üåê';
                btn.setAttribute('aria-label', this.t('languageAria'));
                menu.innerHTML = '';
                LOCALE_ORDER.forEach(code => {
                    const localeMeta = this.getLocaleMeta(code);
                    const btn = document.createElement('button');
                    btn.type = 'button';
                    if (code === this.locale) btn.classList.add('active');
                    btn.textContent = localeMeta.nativeName;
                    btn.addEventListener('click', () => this.selectLanguage(code));
                    menu.appendChild(btn);
                });
            }
            selectLanguage(code) {
                if (!LOCALE_ORDER.includes(code)) {
                    this.closeLanguageMenu();
                    return;
                }
                if (code === this.locale) {
                    this.closeLanguageMenu();
                    return;
                }
                this.locale = code;
                localStorage.setItem(this.LOCALE_KEY, code);
                this.capsulesDirty = true;
                this.dockDirty = true;
                this.closeLanguageMenu();
                this.render();
                this.updateSettingsMenu();
                this.updateLanguageMenu();
                this.updateHelpContent();
                this.updateAriaLabels();
                this.updateDockTabLabels();
            }
            updateHelpContent() {
                const title = document.getElementById('helpTitle');
                const content = document.getElementById('helpContent');
                if (title) title.innerText = this.t('helpTitle');
                if (content) content.innerHTML = this.t('helpContent');
            }
            updateAriaLabels() {
                const helpBtn = document.querySelector('.help-btn');
                if (helpBtn) helpBtn.setAttribute('aria-label', this.t('helpAria'));
                const settingsBtn = document.getElementById('settingsBtn');
                if (settingsBtn) settingsBtn.setAttribute('aria-label', this.t('settingsAria'));
                const langBtn = document.getElementById('languageBtn');
                if (langBtn) langBtn.setAttribute('aria-label', this.t('languageAria'));
                const favBtn = document.querySelector('.btn-fav');
                if (favBtn) favBtn.setAttribute('aria-label', this.t('btnFavAria'));
                const favEditBtn = document.getElementById('activeFavEditBtn');
                if (favEditBtn) {
                    const editLabel = this.t('favEditTitle');
                    favEditBtn.setAttribute('aria-label', editLabel);
                    favEditBtn.setAttribute('title', editLabel);
                }
                const genBtn = document.querySelector('.btn-gen');
                if (genBtn) genBtn.setAttribute('aria-label', this.t('btnGenerateAria'));
                const copyBtn = document.querySelector('.btn-copy');
                if (copyBtn) copyBtn.setAttribute('aria-label', this.t('btnCopyAria'));
                const autoBtn = document.querySelector('.btn-auto-copy');
                if (autoBtn) autoBtn.setAttribute('aria-label', this.t('btnAutoCopyAria'));
                const prev = document.getElementById('btnPrev');
                if (prev) prev.setAttribute('aria-label', this.t('btnPrevAria'));
                const next = document.getElementById('btnNext');
                if (next) next.setAttribute('aria-label', this.t('btnNextAria'));
            }
            updateDockTabLabels() {
                document.querySelectorAll('[data-tab-label="favorites"]').forEach(el => {
                    el.textContent = this.t('favoritesTab');
                });
                document.querySelectorAll('[data-tab-label="history"]').forEach(el => {
                    el.textContent = this.t('historyTab');
                });
                const badge = document.getElementById('dockDeleteBadge');
                if (badge) badge.textContent = this.t('dockDeleteBadge');
                const clearBtn = document.getElementById('dockClearHistory');
                if (clearBtn) clearBtn.setAttribute('title', this.t('confirmClearHistory'));
            }
            openPopover(item, chipEl, retainState = null) {
                this.activePopoverKey = item.id;
                const pop = document.getElementById('popover');
                pop.className = 'popover active';
                const opts = this.getSortedOptions(item.type);
                const itemLabel = this.getTypeLabel(item.type) || item.type;
                let html = `<div class="pop-list">`;
                html += `<div class="pop-section-label">${this.escapeHtml(itemLabel)}</div>`;
                const isRand = item.isRandom ? 'selected' : '';
                html += `<div class="pop-item random-opt ${isRand}" data-random="true">${this.escapeHtml(this.t('popoverRandom'))}</div>`;
                opts.forEach(opt => {
                    const selected = (item.value === opt && !item.isRandom) ? 'selected' : '';
                    const safeVal = this.escapeAttribute(opt);
                    const label = this.escapeHtml(opt);
                    const editLabel = this.escapeAttribute(this.t('favEditTitle'));
                    html += `<div class="pop-item ${selected}" data-val="${safeVal}"><span class="pop-option-label">${label}</span><button type="button" class="pop-edit-btn" data-edit-val="${safeVal}" aria-label="${editLabel}">${this.getEditIcon()}</button></div>`;
                });
                html += `</div>`;
                const placeholder = this.escapeAttribute(this.t('popoverAddPlaceholder'));
                html += `<div class="pop-add-row"><input class="pop-add-input" type="text" placeholder="${placeholder}"></div>`;
                pop.innerHTML = html;
                const rect = chipEl.getBoundingClientRect();
                const box = document.getElementById('editorContainer').getBoundingClientRect();
                let top = (rect.bottom - box.top + 8);
                pop.style.top = top + 'px';
                let left = rect.left - box.left;
                if (left + 220 > box.width) left = box.width - 230; if (left < 0) left = 10;
                pop.style.left = left + 'px';
                const targetScroll = retainState?.scrollTop ?? 0;
                pop.scrollTop = targetScroll;
                const focusVal = retainState?.focusValue;
                requestAnimationFrame(() => {
                    pop.scrollTop = targetScroll;
                    if (focusVal) {
                        const selector = this.escapeSelector(focusVal);
                        const focusEl = pop.querySelector(`.pop-item[data-val="${selector}"]`);
                        if (focusEl) focusEl.scrollIntoView({ block: 'center' });
                    }
                });
                const randomEl = pop.querySelector('.pop-item.random-opt');
                if (randomEl) {
                    randomEl.addEventListener('click', () => this.setRandom(item.id));
                }
                pop.querySelectorAll('.pop-item[data-val]').forEach(el => {
                    const val = el.getAttribute('data-val');
                    el.addEventListener('click', () => {
                        if (el.isLongPress) {
                            el.isLongPress = false;
                            return;
                        }
                        this.setValue(item.id, val);
                    });
                });
                pop.querySelectorAll('.pop-edit-btn').forEach(btn => {
                    btn.addEventListener('click', (event) => {
                        event.stopPropagation();
                        const editVal = btn.getAttribute('data-edit-val');
                        const container = btn.closest('.pop-item');
                        if (container && editVal !== null) {
                            this.enableInlineEdit(container, item.type, editVal);
                        }
                    });
                });
                const addInput = pop.querySelector('.pop-add-input');
                if (addInput) {
                    addInput.addEventListener('keydown', (event) => {
                        if (event.key === 'Enter') {
                            event.preventDefault();
                            this.addOption(item.type, item.id, addInput.value);
                        }
                    });
                    addInput.addEventListener('input', () => {
                        this.highlightPopoverMatch(addInput.value);
                    });
                    requestAnimationFrame(() => {
                        this.highlightPopoverMatch(addInput.value);
                    });
                }
            }
            closePopover() { document.getElementById('popover').classList.remove('active'); this.activePopoverKey = null; }
            setValue(id, val) { const item = this.findItemById(id); if (item) { item.value = val; item.isRandom = false; this.pushHistory(); this.render(); this.closePopover(); } }
            setRandom(id) { const item = this.findItemById(id); if (item) { const opts = this.optionsData[item.type]; if (opts.length) { item.value = opts[Math.floor(Math.random() * opts.length)]; item.isRandom = true; this.pushHistory(); this.render(); } } this.closePopover(); }
            addOption(type, id, val) {
                if (!val.trim()) return;
                if (!this.optionsData[type]) this.optionsData[type] = [];
                if (!this.optionsData[type].includes(val)) {
                    this.optionsData[type].push(val);
                    this.optionsData[type] = this.sortOptionsList(this.optionsData[type]);
                }
                this.setValue(id, val);
            }
            highlightPopoverMatch(value) {
                const pop = document.getElementById('popover');
                if (!pop) return;
                const items = Array.from(pop.querySelectorAll('.pop-item[data-val]'));
                items.forEach(el => el.classList.remove('is-search-match'));
                const query = (value || '').trim().toLowerCase();
                if (!query) return;
                const match = items.find(el => {
                    const val = el.getAttribute('data-val') || '';
                    return val.toLowerCase().startsWith(query);
                });
                if (match) {
                    match.classList.add('is-search-match');
                    match.scrollIntoView({ block: 'nearest' });
                }
            }
            getEditIcon() {
                return `<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M14.586 4.414a2 2 0 012.828 0l1.172 1.172a2 2 0 010 2.828L10 17l-3.9.26.26-3.9 8.226-8.226z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M4 20h16" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>`;
            }
            enableInlineEdit(el, type, oldVal) {
                el.onclick = null;
                const safeVal = this.escapeAttribute(oldVal);
                el.innerHTML = `<input type="text" class="inline-edit-input" value="${safeVal}">`;
                const input = el.querySelector('input'); input.focus();
                const save = () => {
                    const popover = document.getElementById('popover');
                    const prevScroll = popover ? popover.scrollTop : 0;
                    const currentChipId = this.activePopoverKey;
                    const newVal = input.value.trim();
                    if (newVal !== oldVal) {
                        const idx = this.optionsData[type].indexOf(oldVal);
                        if (idx > -1) {
                            if (!newVal) this.optionsData[type].splice(idx, 1);
                            else this.optionsData[type][idx] = newVal;
                            this.items.forEach(i => { if (i.type === type && i.value === oldVal) i.value = newVal; });
                            this.pushHistory();
                        }
                    }
                    this.render();
                    if (currentChipId) {
                        const chip = document.querySelector(`.chip[data-id="${currentChipId}"]`);
                        const item = this.findItemById(currentChipId);
                        if (chip && item) {
                            const focusValue = newVal || oldVal;
                            this.openPopover(item, chip, { scrollTop: prevScroll, focusValue });
                        }
                    }
                };
                input.addEventListener('blur', save);
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        input.blur();
                    }
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        input.value = oldVal;
                        input.blur();
                    }
                });
                input.addEventListener('click', (e) => e.stopPropagation());
                input.addEventListener('mousedown', (e) => e.stopPropagation());
                input.addEventListener('mouseup', (e) => e.stopPropagation());
            }
            openCapEditDialog(key, capEl) {
                if (!capEl) return;
                this.closePopover();
                this.closeCapEditDialog();
                this.activeCapEditKey = key;
                this.activeCapEditEl = capEl;
                capEl.classList.add('cap-editing');
                capEl.isLongPress = false;

                if (!this.capEditDialogEl) {
                    this.capEditDialogEl = document.createElement('div');
                    this.capEditDialogEl.className = 'cap-edit-dialog';
                }
                const dialog = this.capEditDialogEl;
                const currentLabel = this.getTypeLabel(key) || key;
                const safeLabel = this.escapeAttribute(currentLabel);
                dialog.innerHTML = `
                    <div class="cap-edit-title">${this.t('capEditTitle')}<span>${this.t('capEditHint')}</span></div>
                    <input type="text" class="cap-edit-input" value="${safeLabel}">
                    <div class="cap-edit-actions">
                        <button type="button" class="btn-confirm">${this.t('confirmLabel')}</button>
                        <button type="button" class="btn-cancel">${this.t('cancelLabel')}</button>
                    </div>
                `;
                document.body.appendChild(dialog);
                const input = dialog.querySelector('.cap-edit-input');
                const confirmBtn = dialog.querySelector('.btn-confirm');
                const cancelBtn = dialog.querySelector('.btn-cancel');
                confirmBtn.textContent = this.t('confirmLabel');
                cancelBtn.textContent = this.t('cancelLabel');
                const submit = () => this.handleCapEditSubmit(key, input.value);
                confirmBtn.onclick = submit;
                cancelBtn.onclick = () => this.closeCapEditDialog();
                input.onkeydown = (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        submit();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        this.closeCapEditDialog();
                    }
                };
                const updateConfirmState = () => {
                    const trimmed = input.value.trim();
                    const isDelete = trimmed.length === 0;
                    confirmBtn.textContent = isDelete ? this.t('deleteLabel') : this.t('confirmLabel');
                    confirmBtn.classList.toggle('is-danger', isDelete);
                };
                input.addEventListener('input', updateConfirmState);
                setTimeout(() => {
                    input.focus();
                    updateConfirmState();
                }, 0);
                this.positionCapEditDialog(capEl);

                this.capEditOutsideHandler = (event) => {
                    if (!dialog.contains(event.target) && !(this.activeCapEditEl && this.activeCapEditEl.contains(event.target))) {
                        this.closeCapEditDialog();
                    }
                };
                document.addEventListener('mousedown', this.capEditOutsideHandler);
                this.capEditRepositionHandler = () => this.positionCapEditDialog(this.activeCapEditEl);
                window.addEventListener('resize', this.capEditRepositionHandler);
                window.addEventListener('scroll', this.capEditRepositionHandler, true);
            }
            positionCapEditDialog(capEl) {
                if (!this.capEditDialogEl || !capEl) return;
                const rect = capEl.getBoundingClientRect();
                const dialog = this.capEditDialogEl;
                const body = document.documentElement;
                const scrollY = window.scrollY || body.scrollTop;
                const scrollX = window.scrollX || body.scrollLeft;
                dialog.style.top = `${rect.bottom + scrollY + 8}px`;
                let left = rect.left + scrollX;
                const dialogWidth = dialog.offsetWidth || 220;
                const maxLeft = scrollX + body.clientWidth - dialogWidth - 12;
                left = Math.min(Math.max(left, scrollX + 12), maxLeft);
                dialog.style.left = `${left}px`;
            }
            closeCapEditDialog() {
                if (this.capEditOutsideHandler) {
                    document.removeEventListener('mousedown', this.capEditOutsideHandler);
                    this.capEditOutsideHandler = null;
                }
                if (this.capEditRepositionHandler) {
                    window.removeEventListener('resize', this.capEditRepositionHandler);
                    window.removeEventListener('scroll', this.capEditRepositionHandler, true);
                    this.capEditRepositionHandler = null;
                }
                if (this.capEditDialogEl && this.capEditDialogEl.parentNode) {
                    this.capEditDialogEl.parentNode.removeChild(this.capEditDialogEl);
                }
                if (this.activeCapEditEl) {
                    this.activeCapEditEl.classList.remove('cap-editing');
                }
                this.activeCapEditEl = null;
                this.activeCapEditKey = null;
            }
            handleCapEditSubmit(key, value) {
                const next = (value || '').trim();
                if (!next) {
                    if (this.deleteCapsuleKey(key)) {
                        this.closeCapEditDialog();
                    }
                    return;
                }
                const current = this.getTypeLabel(key) || '';
                if (current === next) {
                    this.closeCapEditDialog();
                    return;
                }
                this.renameCapsuleLabel(key, next);
                this.closeCapEditDialog();
            }
            renameCapsuleLabel(key, next) {
                const baseDef = BaseSchema.find(d => d.key === key);
                if (baseDef) {
                    if (next === baseDef.label) {
                        delete this.capLabels[key];
                    } else {
                        this.capLabels[key] = next;
                    }
                }
                const custom = this.customTypes.find(c => c.key === key);
                if (custom) {
                    custom.label = next;
                }
                this.saveData();
                this.capsulesDirty = true;
                this.render();
                this.showToast(this.t('toastCapRenamed'));
            }
            deleteCapsuleKey(key) {
                const baseIdx = BaseSchema.findIndex(def => def.key === key);
                if (baseIdx !== -1 && !this.removedCapsules.includes(key)) {
                    this.removedCapsules.push(key);
                } else {
                    const idx = this.customTypes.findIndex(def => def.key === key);
                    if (idx > -1) {
                        this.customTypes.splice(idx, 1);
                    }
                    delete this.optionsData[key];
                }
                delete this.capLabels[key];
                this.capsuleOrder = this.capsuleOrder.filter(k => k !== key);
                const beforeLength = this.items.length;
                if (beforeLength) {
                    this.items = this.items.filter(item => item.type !== key);
                    if (this.items.length !== beforeLength) {
                        this.pushHistory();
                    }
                }
                this.capsulesDirty = true;
                this.saveData();
                this.render();
                this.showToast(this.t('toastCapDeleted'));
                return true;
            }
            openFavoriteEditDialog(favId, anchorEl) {
                const idx = this.favorites.findIndex(f => f.id === favId);
                if (idx === -1) return;
                const fav = this.favorites[idx];
                this.closeFavoriteEditDialog();
                if (!this.favEditDialogEl) {
                    this.favEditDialogEl = document.createElement('div');
                    this.favEditDialogEl.className = 'cap-edit-dialog';
                }
                const dialog = this.favEditDialogEl;
                const safeName = this.escapeAttribute(fav.name || '');
                dialog.innerHTML = `
                    <div class="cap-edit-title">${this.t('favEditTitle')}<span>${this.t('favEditHint')}</span></div>
                    <input type="text" class="cap-edit-input" value="${safeName}">
                    <div class="cap-edit-actions">
                        <button type="button" class="btn-confirm">${this.t('confirmLabel')}</button>
                        <button type="button" class="btn-cancel">${this.t('cancelLabel')}</button>
                    </div>
                `;
                document.body.appendChild(dialog);
                const input = dialog.querySelector('.cap-edit-input');
                const confirmBtn = dialog.querySelector('.btn-confirm');
                const cancelBtn = dialog.querySelector('.btn-cancel');
                const submit = () => this.handleFavoriteEditSubmit(input.value);
                confirmBtn.onclick = submit;
                cancelBtn.onclick = () => this.closeFavoriteEditDialog();
                input.onkeydown = (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        submit();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        this.closeFavoriteEditDialog();
                    }
                };
                const updateState = () => {
                    const trimmed = input.value.trim();
                    const isDelete = trimmed.length === 0;
                    confirmBtn.textContent = isDelete ? this.t('deleteLabel') : this.t('confirmLabel');
                    confirmBtn.classList.toggle('is-danger', isDelete);
                };
                input.addEventListener('input', updateState);
                setTimeout(() => {
                    input.focus();
                    input.select();
                    updateState();
                }, 0);
                this.activeFavEdit = { favId, anchor: anchorEl };
                this.positionFavoriteEditDialog(anchorEl);
                this.favEditOutsideHandler = (event) => {
                    if (!dialog.contains(event.target) && !(anchorEl && anchorEl.contains(event.target))) {
                        this.closeFavoriteEditDialog();
                    }
                };
                document.addEventListener('mousedown', this.favEditOutsideHandler);
                this.favEditRepositionHandler = () => this.positionFavoriteEditDialog(anchorEl);
                window.addEventListener('resize', this.favEditRepositionHandler);
                window.addEventListener('scroll', this.favEditRepositionHandler, true);
            }
            positionFavoriteEditDialog(anchorEl) {
                if (!this.favEditDialogEl || !anchorEl) return;
                const rect = anchorEl.getBoundingClientRect();
                const dialog = this.favEditDialogEl;
                const scrollY = window.scrollY || document.documentElement.scrollTop;
                const scrollX = window.scrollX || document.documentElement.scrollLeft;
                dialog.style.top = `${rect.bottom + scrollY + 8}px`;
                let left = rect.left + scrollX;
                const dialogWidth = dialog.offsetWidth || 220;
                const maxLeft = scrollX + document.documentElement.clientWidth - dialogWidth - 12;
                if (left < scrollX + 12) left = scrollX + 12;
                if (left > maxLeft) left = maxLeft;
                dialog.style.left = `${left}px`;
            }
            closeFavoriteEditDialog() {
                if (this.favEditOutsideHandler) {
                    document.removeEventListener('mousedown', this.favEditOutsideHandler);
                    this.favEditOutsideHandler = null;
                }
                if (this.favEditRepositionHandler) {
                    window.removeEventListener('resize', this.favEditRepositionHandler);
                    window.removeEventListener('scroll', this.favEditRepositionHandler, true);
                    this.favEditRepositionHandler = null;
                }
                if (this.favEditDialogEl && this.favEditDialogEl.parentNode) {
                    this.favEditDialogEl.parentNode.removeChild(this.favEditDialogEl);
                }
                this.activeFavEdit = null;
            }
            handleFavoriteEditSubmit(value) {
                if (!this.activeFavEdit) return;
                const idx = this.favorites.findIndex(f => f.id === this.activeFavEdit.favId);
                if (idx === -1) return;
                const trimmed = (value || '').trim();
                if (!trimmed) {
                    this.deleteFavorite(idx);
                    this.closeFavoriteEditDialog();
                    return;
                }
                this.renameFavorite(idx, trimmed);
                this.closeFavoriteEditDialog();
            }
            renameFavorite(idx, name) {
                if (idx < 0 || idx >= this.favorites.length) return;
                this.favorites[idx].name = name;
                this.saveData();
                this.renderDockList();
                if (this.favorites[idx].id === this.activeFavoriteId) {
                    this.activeFavoriteName = name;
                    this.updateActiveFavoriteLabel();
                }
                this.showToast(this.t('toastFavoriteRenamed'));
            }
            createFavoriteChip(fav, index) {
                const chip = this.el('div', 'fav-name-chip', `${fav.name || ''}`.trim());
                chip.draggable = true;
                chip.dataset.favId = fav.id;
                chip.dataset.dockId = `fav_${fav.id}`;
                if (Number.isFinite(index)) {
                    chip.dataset.favIndex = index;
                }
                const bg = this.isDarkTheme() ? (fav.darkColor || fav.color) : fav.color;
                if (bg) {
                    chip.style.backgroundColor = bg;
                }
                if (this.latestFavoriteId === fav.id) {
                    chip.classList.add('pop-in');
                    chip.addEventListener('animationend', () => chip.classList.remove('pop-in'), { once: true });
                }
                chip.onclick = () => {
                    if (chip.isLongPress) {
                        chip.isLongPress = false;
                        return;
                    }
                    if (chip.isDragging) {
                        chip.isDragging = false;
                        return;
                    }
                    this.applyFavorite(fav.id);
                };
                chip.addEventListener('dragstart', (e) => {
                    chip.classList.add('dragging');
                    chip.isDragging = true;
                    this.favoriteDragId = fav.id;
                    this.dragType = 'favorite';
                    if (e.dataTransfer) {
                        try {
                            e.dataTransfer.setData('text/plain', JSON.stringify({ source: 'favorite', id: fav.id }));
                        } catch (err) { }
                        e.dataTransfer.effectAllowed = 'copyMove';
                    }
                    document.body.classList.add('is-dragging');
                });
                chip.addEventListener('dragend', () => {
                    chip.classList.remove('dragging');
                    chip.isDragging = false;
                    this.favoriteDragId = null;
                    this.dragType = null;
                    document.body.classList.remove('is-dragging');
                    this.clearGapPreview();
                    if (this.favoriteGapPreview) this.favoriteGapPreview.clear();
                });
                this.addLongPress(chip, () => {
                    this.openFavoriteEditDialog(fav.id, chip);
                    if (navigator.vibrate) navigator.vibrate(50);
                }, 600);
                return chip;
            }
            createFavoriteGap(index, position) {
                const gap = this.el('div', 'fav-drop-zone');
                if (position) gap.classList.add(position);
                gap.dataset.favIndex = index;
                gap.ondragover = (e) => {
                    if (!this.favoriteDragId) return;
                    e.preventDefault();
                    gap.classList.add('drag-over-gap');
                    if (this.favoriteGapPreview) this.favoriteGapPreview.set(index);
                };
                gap.ondragleave = () => {
                    gap.classList.remove('drag-over-gap');
                    if (this.favoriteGapPreview) this.favoriteGapPreview.clear(index);
                };
                gap.ondrop = (e) => {
                    if (!this.favoriteDragId) return;
                    e.preventDefault();
                    gap.classList.remove('drag-over-gap');
                    if (this.favoriteGapPreview) this.favoriteGapPreview.clear();
                    this.handleFavoriteDrop(index);
                };
                if (this.favoriteGapPreview) this.favoriteGapPreview.registerGap(index, gap);
                return gap;
            }
            handleFavoriteDrop(insertIndex) {
                const sourceIdx = this.favorites.findIndex(f => f.id === this.favoriteDragId);
                if (sourceIdx === -1) return;
                const [moved] = this.favorites.splice(sourceIdx, 1);
                let targetIdx = insertIndex;
                if (sourceIdx < insertIndex) {
                    targetIdx = Math.max(0, insertIndex - 1);
                }
                targetIdx = Math.min(Math.max(targetIdx, 0), this.favorites.length);
                this.favorites.splice(targetIdx, 0, moved);
                this.favoriteDragId = null;
                this.saveData();
                this.renderDockList();
            }
            action(type) {
                const actions = {
                    generate: () => this.rollDice(),
                    fav: () => this.addToFavorites(),
                    reset: () => this.resetApp(),
                    export: () => this.exportJSON(),
                    import: () => this.importJSON()
                };
                if (actions[type]) actions[type]();
            }
            rollDice() {
                const btn = document.querySelector('.btn-gen');
                if (btn) {
                    btn.classList.remove('animating');
                    void btn.offsetWidth;
                    btn.classList.add('animating');
                    const icon = btn.querySelector('.dice-icon');
                    if (icon) {
                        icon.addEventListener('animationend', () => {
                            btn.classList.remove('animating');
                        }, { once: true });
                    }
                }
                this.generateValues(true);
                this.recordRollHistory();
                if (this.isAutoCopyEnabled) {
                    this.copyToClipboard({ toastMessage: this.t('toastPromptCopied') });
                }
            }
            recordRollHistory() {
                const prompt = this.generatePrompt();
                if (!prompt) return;
                const entry = {
                    id: Date.now(),
                    items: JSON.parse(JSON.stringify(this.items)),
                    text: prompt
                };
                this.rollHistory.unshift(entry);
                if (this.rollHistory.length > this.MAX_ROLL_HISTORY) {
                    this.rollHistory.pop();
                }
                this.saveData();
                this.renderDockList();
            }
            toggleAutoCopy(forceState) {
                const nextState = typeof forceState === 'boolean' ? forceState : !this.isAutoCopyEnabled;
                this.isAutoCopyEnabled = nextState;
                localStorage.setItem(this.AUTO_COPY_STORAGE_KEY, nextState ? '1' : '0');
                this.updateAutoCopyUI();
                this.showToast(nextState ? this.t('toastAutoCopyOn') : this.t('toastAutoCopyOff'));
            }
            updateAutoCopyUI() {
                const btn = document.querySelector('.btn-auto-copy');
                if (!btn) return;
                btn.classList.toggle('is-active', !!this.isAutoCopyEnabled);
                btn.setAttribute('aria-pressed', this.isAutoCopyEnabled ? 'true' : 'false');
            }
            copyToClipboard(opts = {}) {
                const { toastMessage = this.t('toastCopy') } = opts;
                const text = this.generatePrompt();
                if (!text) return;
                navigator.clipboard.writeText(text).then(() => {
                    if (toastMessage) {
                        this.showToast(toastMessage);
                    }
                });
            }
            copyFavorite(text) {
                if (!text) return;
                navigator.clipboard.writeText(text).then(() => this.showToast(this.t('toastCopyShort')));
            }
            clearAllStorage() {
                try {
                    localStorage.removeItem(this.STORAGE_KEY);
                    localStorage.removeItem('promania-theme');
                    localStorage.removeItem(this.AUTO_COPY_STORAGE_KEY);
                    localStorage.removeItem(this.LOCALE_KEY);
                } catch (err) {
                    console.warn('Failed to clear storage', err);
                }
                this.clearActiveFavoriteLabel();
            }
            resetApp() {
                if (!confirm(this.t('confirmReset'))) return;
                this.clearAllStorage();
                this.isAutoCopyEnabled = false;
                this.locale = 'en';
                document.documentElement.setAttribute('data-theme', 'dark');
                this.updateThemeIcon('dark');
                this.clearActiveFavoriteLabel();
                this.initDefaultData();
                this.pushHistory();
                this.updateAutoCopyUI();
                this.render();
                this.updateSettingsMenu();
                this.updateLanguageMenu();
                this.updateHelpContent();
                this.showToast(this.t('toastReset'));
            }
            exportJSON() {
                const data = {
                    schemaVersion: this.DATA_SCHEMA_VERSION,
                    version: this.APP_VERSION,
                    favorites: this.favorites,
                    customTypes: this.customTypes,
                    capLabels: this.capLabels
                };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
                const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = "prompts.json"; a.click();
            }
            importJSON() {
                const input = document.createElement('input'); input.type = 'file'; input.accept = '.json';
                input.onchange = e => {
                    const reader = new FileReader();
                    reader.onload = ev => {
                        try {
                            const data = JSON.parse(ev.target.result);
                            this.applyImportedData(data);
                        } catch (err) { alert(this.t('importError') + err.message); }
                    };
                    reader.readAsText(e.target.files[0]);
                };
                input.click();
            }
            applyImportedData(payload) {
                if (!payload || typeof payload !== 'object') {
                    alert(this.t('importError') + 'Invalid file');
                    return;
                }
                if (!this.validateSchemaVersion(payload)) {
                    alert(this.t('importError') + 'Incompatible version');
                    return;
                }
                const hasFullState = Array.isArray(payload.items) || payload.optionsData;
                if (hasFullState) {
                    const sanitized = this.sanitizeFullStatePayload(payload);
                    if (!sanitized) {
                        alert(this.t('importError') + 'Invalid state');
                        return;
                    }
                    if (!confirm(this.t('confirmReset'))) return;
                    this.clearAllStorage();
                    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(sanitized));
                    location.reload();
                    return;
                }
                const partial = this.sanitizePartialImport(payload);
                if (!partial) {
                    alert(this.t('importError') + 'Invalid favorites data');
                    return;
                }
                this.initDefaultData();
                this.favorites = partial.favorites;
                this.ensureFavoriteNames();
                this.customTypes = partial.customTypes;
                this.capLabels = partial.capLabels;
                this.syncCapsuleOrder();
                this.capsulesDirty = true;
                this.dockDirty = true;
                this.saveData();
                this.render();
                this.showToast(this.t('toastImportSuccess'));
            }
            updateFavButtonState() {
                const btn = document.querySelector('.btn-fav');
                if (!btn) return;
                const prompt = this.generatePrompt();
                const matchingFav = this.favorites.find(f => f.text === prompt && prompt !== "");
                const isMatch = !!matchingFav;
                btn.classList.toggle('is-active', isMatch);
                if (isMatch) {
                    this.activeFavoriteId = matchingFav.id;
                    this.activeFavoriteName = matchingFav.name || '';
                    this.skipFavoriteLabelClear = false;
                    this.updateActiveFavoriteLabel();
                } else if (this.activeFavoriteId || this.activeFavoriteName) {
                    this.clearActiveFavoriteLabel();
                }
            }
            addToFavorites() {
                const text = this.generatePrompt();
                if (!text) { alert(this.t('alertEmptyPrompt')); return; }
                const existingIdx = this.favorites.findIndex(f => f.text === text);
                if (existingIdx !== -1) {
                    this.deleteFavorite(existingIdx);
                    return;
                }
                const favItem = {
                    id: Date.now(),
                    name: this.generateFavoriteName(),
                    text: text,
                    items: JSON.parse(JSON.stringify(this.items))
                };
                this.ensureFavoriteColor(favItem);
                this.favorites.unshift(favItem);
                this.latestFavoriteId = favItem.id;
                this.saveData();
                this.switchDockTab('favorites');
                this.showToast(this.t('toastFavoritesAdded'));
                this.updateFavButtonState();
            }
            buildChipPreviewHTML(items = []) {
                if (!Array.isArray(items) || items.length === 0) {
                    return `<span class="history-summary">${this.t('emptyPromptPreview')}</span>`;
                }
                let chipsHtml = '';
                items.forEach((i, iIdx) => {
                    if (!i.value) return;
                    this.ensureItemColorPair(i);
                    const color = this.isDarkTheme() ? (i.darkColor || i.color) : i.color;
                    const safeColor = this.sanitizeColorValue(color);
                    let classNames = 'fav-chip';
                    if (i.linkNext && iIdx < items.length - 1) classNames += ' linked-left';
                    if (iIdx > 0 && items[iIdx - 1].linkNext) classNames += ' linked-right';
                    const styleAttr = safeColor ? ` style="background-color:${safeColor}"` : '';
                    chipsHtml += `<span class="${classNames}"${styleAttr}>${this.escapeHtml(i.value)}</span>`;
                });
                return chipsHtml || `<span class="history-summary">${this.t('emptyPromptPreview')}</span>`;
            }
            applyFavorite(favId) {
                this.closeFavoriteEditDialog();
                const fav = this.favorites.find(f => f.id === favId);
                if (!fav) return;

                this.items = JSON.parse(JSON.stringify(fav.items));
                this.activeFavoriteId = fav.id;
                this.activeFavoriteName = fav.name || '';
                this.skipFavoriteLabelClear = true;
                this.items.forEach(item => this.ensureItemColorPair(item));

                this.pushHistory();
                this.render();
                this.showToast(this.t('toastFavoriteApplied'));
                this.updateFavButtonState();
                this.updateActiveFavoriteLabel();
            }
            pushFavoriteUndo(entry) {
                if (!entry || !entry.favorite) return;
                if (!this.favoriteUndoStack) this.favoriteUndoStack = [];
                this.favoriteUndoStack.push(entry);
                if (this.favoriteUndoStack.length > (this.FAVORITE_UNDO_LIMIT || 10)) {
                    this.favoriteUndoStack.shift();
                }
            }
            undoFavoriteDeletion() {
                if (!this.favoriteUndoStack || this.favoriteUndoStack.length === 0) return false;
                const entry = this.favoriteUndoStack.pop();
                if (!entry || !entry.favorite) return false;
                const targetIndex = Math.min(Math.max(entry.index ?? this.favorites.length, 0), this.favorites.length);
                this.favorites.splice(targetIndex, 0, entry.favorite);
                this.saveData();
                this.renderDockList();
                this.updateFavButtonState();
                this.showToast(this.t('toastFavoriteRestored'));
                return true;
            }
            deleteFavorite(idx, options = {}) {
                if (idx < 0 || idx >= this.favorites.length) return;
                const { skipToast = false, recordUndo = true } = options;
                const removed = this.favorites[idx];
                if (!removed) return;
                const wasActive = removed.id === this.activeFavoriteId;
                const removedClone = JSON.parse(JSON.stringify(removed));
                this.favorites.splice(idx, 1);
                if (recordUndo) {
                    this.pushFavoriteUndo({ favorite: removedClone, index: idx });
                }
                this.saveData();
                if (this.favorites.length === 0) this.isDockDeleteMode = false;
                if (wasActive) {
                    this.clearActiveFavoriteLabel();
                }
                this.closeFavoriteEditDialog();
                this.renderDockList();
                this.updateFavButtonState();
                if (!skipToast) {
                    this.showToast(this.t('toastFavoriteDeleted'));
                }
                return removed;
            }
            deleteRollHistoryEntry(idx) {
                if (idx < 0 || idx >= this.rollHistory.length) return;
                this.rollHistory.splice(idx, 1);
                if (this.rollHistory.length === 0) this.isDockDeleteMode = false;
                this.saveData();
                this.renderDockList();
            }
            clearRollHistory() {
                if (!this.rollHistory.length) return;
                if (!confirm(this.t('confirmClearHistory'))) return;
                this.rollHistory = [];
                this.isDockDeleteMode = false;
                this.saveData();
                this.renderDockList();
                this.showToast(this.t('toastRollHistoryCleared'));
            }
            animateDockRemoval(itemEl, callback) {
                if (!itemEl) { callback?.(); return; }
                itemEl.classList.add('deleting');
                itemEl.addEventListener('animationend', () => {
                    callback?.();
                }, { once: true });
            }
            switchDockTab(tab) {
                this.activeDockTab = tab;
                if (tab === 'favorites') {
                    this.isDockDeleteMode = false;
                }
                this.renderDockList();
            }
            renderDockList() {
                this.closeFavoriteEditDialog();
                if (this.activeDockTab !== 'favorites' && this.activeDockTab !== 'history') {
                    this.activeDockTab = 'favorites';
                }
                const section = document.getElementById('dockSection');
                const list = document.getElementById('dockList');
                if (!section || !list) return;
                if (this.favoriteGapPreview) this.favoriteGapPreview.clear();
                this.dockDirty = false;
                const prevPositions = list.childElementCount ? this.captureDockPositions(list) : null;

                const favCount = document.getElementById('favCount');
                if (favCount) favCount.innerText = `(${this.favorites.length})`;
                const historyCount = document.getElementById('historyCount');
                if (historyCount) historyCount.innerText = `(${this.rollHistory.length})`;

                const hasFavorites = this.favorites.length > 0;
                const hasHistory = this.rollHistory.length > 0;
                section.classList.add('active');
                const tabs = section.querySelectorAll('.dock-tab');
                tabs.forEach(btn => btn.classList.toggle('active', btn.dataset.tab === this.activeDockTab));
                const clearBtn = document.getElementById('dockClearHistory');
                if (clearBtn) {
                    if (this.activeDockTab === 'history') {
                        clearBtn.style.display = 'inline-flex';
                        clearBtn.disabled = !hasHistory;
                    } else {
                        clearBtn.style.display = 'none';
                    }
                }

                list.innerHTML = '';
                if (this.activeDockTab === 'history') {
                    this.renderRollHistoryList(list, hasHistory);
                } else {
                    this.renderFavoriteList(list, hasFavorites);
                }
                if (prevPositions) {
                    this.animateDockReflow(prevPositions);
                }
                this.updateDockTabLabels();
            }
            renderFavoriteList(list, hasFavorites) {
                if (!hasFavorites) {
                    list.innerHTML = `<div class="dock-empty">${this.t('favoritesEmpty')}</div>`;
                    this.latestFavoriteId = null;
                    if (this.favoriteGapPreview) this.favoriteGapPreview.reset();
                    return;
                }
                const board = document.createElement('div');
                board.className = 'fav-chip-board';

                if (this.favoriteGapPreview) this.favoriteGapPreview.reset();

                const appendGap = (index) => {
                    const isHead = index === 0;
                    const isTail = index === this.favorites.length;
                    const position = isHead ? 'head' : (isTail ? 'tail' : undefined);
                    board.appendChild(this.createFavoriteGap(index, position));
                };

                appendGap(0);
                this.favorites.forEach((fav, idx) => {
                    board.appendChild(this.createFavoriteChip(fav, idx));
                    appendGap(idx + 1);
                });

                list.appendChild(board);
                this.latestFavoriteId = null;
            }
            renderRollHistoryList(list, hasHistory) {
                if (!hasHistory) {
                    list.innerHTML = `<div class="dock-empty">${this.t('historyEmpty')}</div>`;
                    this.isDockDeleteMode = false;
                    return;
                }

                this.rollHistory.forEach((entry, idx) => {
                    const item = document.createElement('div');
                    item.className = 'history-item';
                    item.dataset.dockId = `roll_${entry.id}`;

                    const content = document.createElement('div');
                    content.className = 'fav-content';
                    const summaryText = (entry.text || '').trim();
                    if (summaryText) {
                        const summaryEl = document.createElement('span');
                        summaryEl.className = 'history-text';
                        summaryEl.textContent = summaryText;
                        content.appendChild(summaryEl);
                    } else {
                        content.innerHTML = this.buildChipPreviewHTML(entry.items || []);
                    }
                    item.appendChild(content);

                    const actions = document.createElement('div');
                    actions.className = 'fav-actions';
                    const copyBtn = document.createElement('div');
                    copyBtn.className = 'fav-btn';
                    copyBtn.innerHTML = ICON_COPY;
                    copyBtn.onclick = (event) => {
                        event.stopPropagation();
                        this.copyFavorite(entry.text || '');
                    };
                    actions.appendChild(copyBtn);
                    item.appendChild(actions);

                    item.onclick = () => {
                        this.items = JSON.parse(JSON.stringify(entry.items || []));
                        this.pushHistory();
                        this.render();
                        this.showToast(this.t('toastRollRestored'));
                    };

                    list.appendChild(item);
                });
            }
        }
        const app = new PromptManager();
    </script>
    <div class="help-modal-overlay" id="helpModal">
        <div class="help-modal">
            <button class="help-close">√ó</button>
            <div class="help-title" id="helpTitle"></div>
            <div class="help-content" id="helpContent"></div>
        </div>
    </div>
</body>

</html>
